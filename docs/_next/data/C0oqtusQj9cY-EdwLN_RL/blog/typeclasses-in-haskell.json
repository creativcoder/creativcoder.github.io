{"pageProps":{"post":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    pre: \"pre\",\n    img: \"img\",\n    blockquote: \"blockquote\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Haskell as a language always fascinates me with its unique typesystem and constructs that offers expressiveness unlike other languages.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In this article, I want to share something I learned about type classes in Haskell. To do that, we need an example!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's create a simple function in haskell that does some arithmetic to understand typeclasses.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So here's our \", _jsx(_components.code, {\n        children: \"magical\"\n      }), \" function:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-python\",\n        children: \"-- simple_haskell.hs\\nmagical x y = (x + y) * (x - y)\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let's load this up in \", _jsx(_components.code, {\n        children: \"ghci\"\n      }), \" real quick.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-python\",\n        children: \"ghci> :l simple_haskell.hs\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let's see the type of function \", _jsx(_components.code, {\n        children: \"magical\"\n      }), \" by running:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-python\",\n        children: \":t magical\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We get something like:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-python\",\n        children: \"Num a => a -> a -> a\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"That's a lot of \", _jsx(_components.code, {\n        children: \"a\"\n      }), \"'s and I could hardly figure out what all that meant.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://media.giphy.com/media/2wYWi6n5oNdIAH5bLW/giphy.gif\",\n        alt: \"gif\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Y u no simple to read haskell. :|\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"After endless sessions of skimming the interwebs here and there, I think I have a decent understanding from which to reason further about typeclasses.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So, let's visit our signature again and break it down, shall we!\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In the signature above, the  \", _jsx(_components.code, {\n        children: \"a -> a -> a\"\n      }), \" denotes that our function \", _jsx(_components.code, {\n        children: \"magical\"\n      }), \" takes two types \", _jsx(_components.code, {\n        children: \"a\"\n      }), \" (the first two \", _jsx(_components.code, {\n        children: \"a\"\n      }), \"'s) and returns a type \", _jsx(_components.code, {\n        children: \"a\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Take a note that the last one always is the return type. Actually, there is more going on here, which is called currying in functional lingo, but that will be part of another post.\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"Side note: Functions in haskell always have an arity of 1, which means they always have one arguement.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It's an unfamiliar syntax to many but not until you learn about lambda calculus or if you have some functional programming background.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Anyways, what's with the first \", _jsx(_components.code, {\n        children: \"Num a\"\n      }), \". This is what what we are interested in.\\nThe \", _jsx(_components.code, {\n        children: \"Num\"\n      }), \" in \", _jsx(_components.code, {\n        children: \"Num a\"\n      }), \", is a \", _jsx(_components.code, {\n        children: \"typeclass\"\n      }), \" in haskell, and the \", _jsx(_components.code, {\n        children: \"a\"\n      }), \", is what we call a type variable, (just a placeholder if you will).\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Typeclasses in haskell are a construct which encapsulates different functions or behaviors for any type, that falls under that typeclass. They allow you to generalize over a multitude of types confirming to a set of protocol.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As an analogy, the \", _jsx(_components.code, {\n        children: \"Num\"\n      }), \" typeclass in Haskell is a holder of a family of concrete \", _jsx(_components.code, {\n        children: \"Num\"\n      }), \"ish types, which can be \", _jsx(_components.code, {\n        children: \"int\"\n      }), \", \", _jsx(_components.code, {\n        children: \"long\"\n      }), \", \", _jsx(_components.code, {\n        children: \"float\"\n      }), \", \", _jsx(_components.code, {\n        children: \"double\"\n      }), \" etc. Similary \", _jsx(_components.code, {\n        children: \"Eq\"\n      }), \" is another typeclass in haskell used to provide total ordering semantics for two comparable types.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"That's all folks. I intend to update this article in future with more details.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"meta":{"excerpt":"Haskell as a language always fascinates me with its unique typesystem and constructs that offer expressiveness unlike other languages. In this article, I want to share something I learned about type classes in haskell.","slug":"typeclasses-in-haskell","title":"A short intro to type classes in Haskell","tags":["functional programming","haskell","lambda calculus","type theory"],"date":"Sun Jun 19 2016 05:30:00 GMT+0530 (India Standard Time)","author":"creativcoder","readingTime":"2min"}}},"__N_SSG":true}