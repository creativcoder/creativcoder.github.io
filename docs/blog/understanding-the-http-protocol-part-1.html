<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>creativcoder</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/ab2a2959b9ba8661.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ab2a2959b9ba8661.css" data-n-g=""/><link rel="preload" href="/_next/static/css/f16eaa9e44b97d3f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f16eaa9e44b97d3f.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-9faa89de3ee6e754.js" defer=""></script><script src="/_next/static/chunks/framework-a87821de553db91d.js" defer=""></script><script src="/_next/static/chunks/main-32a43e1092778ede.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2e588ff4f55f23af.js" defer=""></script><script src="/_next/static/chunks/167-4ae4480dee839e87.js" defer=""></script><script src="/_next/static/chunks/675-f43734e7770ea31e.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-c606869ed04a3d0b.js" defer=""></script><script src="/_next/static/C0oqtusQj9cY-EdwLN_RL/_buildManifest.js" defer=""></script><script src="/_next/static/C0oqtusQj9cY-EdwLN_RL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="" style="position:fixed;top:0;left:0;height:3px;background:transparent;z-index:99999999999;width:100%"><div class="" style="height:100%;background:#4CE0B3;transition:all 500ms ease;width:0%"><div style="box-shadow:0 0 10px #4CE0B3, 0 0 10px #4CE0B3;width:5%;opacity:1;position:absolute;height:100%;transition:all 500ms ease;transform:rotate(3deg) translate(0px, -4px);left:-10rem"></div></div></div><div class="flex min-h-screen w-screen overflow-hidden flex-col items-center dark:bg-[#242729] bg-slate-200 backdrop" style="opacity:0.5;background-color:#E2E8F0"><div class="max-w-2xl md:max-w-3xl lg:max-w-4xl space-y-12 w-screen sticky"><nav class="bg-[#f6f8f9] dark:bg-[#2b2e30] dark:shadow-md m-3 rounded-lg shadow-sm backdrop-filter backdrop-blur-md bg-opacity-40 sticky top-0 mt-10"><div class="mx-auto p-4"><div class="flex justify-between"><div class="cursor-pointer flex space-x-2 items-center"><div><img src="/logo_v3.svg" width="26" class="pt-0.5 invert"/></div><div class="text-lg dark:text-white hidden md:block">creativcoder</div></div><div class="flex items-center pr-2"><ul class="hidden md:flex md:space-x-4 pr-3"><a class="hover:text-slate-500 dark:text-slate-200 text-slate-700 transition flex items-center" href="/blog"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M18.404 2.998c-.757-.754-2.077-.751-2.828.005l-1.784 1.791L11.586 7H7a.998.998 0 0 0-.939.658l-4 11c-.133.365-.042.774.232 1.049l2 2a.997.997 0 0 0 1.049.232l11-4A.998.998 0 0 0 17 17v-4.586l2.207-2.207v-.001h.001L21 8.409c.378-.378.586-.881.585-1.415 0-.535-.209-1.038-.588-1.415l-2.593-2.581zm-3.111 8.295A.996.996 0 0 0 15 12v4.3l-9.249 3.363 4.671-4.671c.026.001.052.008.078.008A1.5 1.5 0 1 0 9 13.5c0 .026.007.052.008.078l-4.671 4.671L7.7 9H12c.266 0 .52-.105.707-.293L14.5 6.914 17.086 9.5l-1.793 1.793zm3.206-3.208-2.586-2.586 1.079-1.084 2.593 2.581-1.086 1.089z"></path></svg></a><a class="hover:text-slate-500 dark:text-slate-200 text-slate-700 transition flex items-center" href="https://youtube.com/@creativcoder"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="24" width="24" xmlns="http://www.w3.org/2000/svg"><g><path fill="none" d="M0 0h24v24H0z"></path><path fill-rule="nonzero" d="M19.606 6.995c-.076-.298-.292-.523-.539-.592C18.63 6.28 16.5 6 12 6s-6.628.28-7.069.403c-.244.068-.46.293-.537.592C4.285 7.419 4 9.196 4 12s.285 4.58.394 5.006c.076.297.292.522.538.59C5.372 17.72 7.5 18 12 18s6.629-.28 7.069-.403c.244-.068.46-.293.537-.592C19.715 16.581 20 14.8 20 12s-.285-4.58-.394-5.005zm1.937-.497C22 8.28 22 12 22 12s0 3.72-.457 5.502c-.254.985-.997 1.76-1.938 2.022C17.896 20 12 20 12 20s-5.893 0-7.605-.476c-.945-.266-1.687-1.04-1.938-2.022C2 15.72 2 12 2 12s0-3.72.457-5.502c.254-.985.997-1.76 1.938-2.022C6.107 4 12 4 12 4s5.896 0 7.605.476c.945.266 1.687 1.04 1.938 2.022zM10 15.5v-7l6 3.5-6 3.5z"></path></g></svg></a><a class="hover:text-slate-500 dark:text-slate-200 text-slate-700 transition flex items-center" href="/about"><svg stroke="currentColor" fill="none" stroke-width="0" viewBox="0 0 24 24" height="24" width="24" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M16 9C16 11.2091 14.2091 13 12 13C9.79086 13 8 11.2091 8 9C8 6.79086 9.79086 5 12 5C14.2091 5 16 6.79086 16 9ZM14 9C14 10.1046 13.1046 11 12 11C10.8954 11 10 10.1046 10 9C10 7.89543 10.8954 7 12 7C13.1046 7 14 7.89543 14 9Z" fill="currentColor"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1ZM3 12C3 14.0902 3.71255 16.014 4.90798 17.5417C6.55245 15.3889 9.14627 14 12.0645 14C14.9448 14 17.5092 15.3531 19.1565 17.4583C20.313 15.9443 21 14.0524 21 12C21 7.02944 16.9706 3 12 3C7.02944 3 3 7.02944 3 12ZM12 21C9.84977 21 7.87565 20.2459 6.32767 18.9878C7.59352 17.1812 9.69106 16 12.0645 16C14.4084 16 16.4833 17.1521 17.7538 18.9209C16.1939 20.2191 14.1881 21 12 21Z" fill="currentColor"></path></svg></a></ul><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="md:hidden block"><path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path></svg></div></div></div></nav><div><article class="dark:text-slate-200 dark:prose-headings:text-slate-200 dark:prose-code:text-slate-200 dark:prose-blockquote:text-slate-200 dark:prose-strong:text-slate-100 dark:prose-pre:bg-zinc-900 dark:prose-pre:shadow-md dark:prose-pre:border-gray-600 dark:prose-pre:border-[1.4px] dark:prose-a:text-slate-200 prose prose-xl flex flex-col mx-auto max-w-6xl justify-center pl-6 pr-6 prose-p:m-3 prose-headings:mb-3 prose-headings:mt-3 prose-a:font-bold prose-img:rounded-lg prose-img:m-auto prose-img:w-full prose-img:shadow-lg prose-code:font-jetbrains prose-pre:p-0 prose-a:no-underline prose-h1:text-4xl prose-h1:pl-2 prose-h2:pl-2 prose-blockquote:border-slate-600 prose-h2:text-xl"><div class="flex flex-col"><p class="text-4xl font-bold">Understanding the HTTP Protocol in simple terms: Part 1</p><div class="pt-3 flex justify-between flex-row-reverse"><div class="flex items-center space-x-2"><p class="text-sm">16th February 2016</p></div><div class="flex items-center space-x-2"><p class="text-sm tracking-wide">creativcoder<!-- --> / <!-- -->6min<!-- --></p></div></div><div class="flex justify-center"><hr class="mb-8 h-px bg-gray-400 border-0 dark:bg-gray-500 w-full"/></div></div><p><img src="https://images.unsplash.com/photo-1531765408077-9a1f85f90df1?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1173&amp;q=80" alt="cover image"/></p>
<!-- --><p>I have seen many of my peers ask from time to time, what is http, and how it works.
Also as a web developer understanding HTTP protocol is an essential asset to be able to think in a way, as to how to architecture your web apps, so that it follows the semantics of HTTP.</p>
<!-- --><p>This post will discuss on the abstraction/medium on which the &#x27;user facing&#x27; internet stands on.</p>
<!-- --><p>A bit of background first!</p>
<!-- --><p>Similar to how we as humans need a language with a structure to communicate and exchange ideas effectively among our peers; computers need to talk to different computers over a network. And being dumb machines, they need every detail communicated in the message in a precise manner.
HTTP is just that language through which computers can talk to other remote computers over a network.
Technically speaking, HTTP is a request/response based, stateless (will come to this on a follow up post) application layer protocol, implemented on top of a stateful protcol which is TCP/IP usually.
TCP/IP is another lower layer of abstraction for communicating bytes reliably over the network.</p>
<!-- --><p>In the same way how our english sentences have a formal structure and semantic; the HTTP protocol also has a formal description of it, usually defined in a spec sheet, called <!-- --><a href="https://www.ietf.org/rfc.html">RFC</a>&#x27;s (Request for Comments).
These are standardized documents, that are accepted globally and maintained by IETF(Internet Engineering Task Force).<!-- --></p>
<!-- --><p>The HTTP&#x27;s <!-- --><a href="https://www.rfc-editor.org/rfc/rfc2616.txt">RFC</a> describes in details, every aspect of the request reponse cycle, that can happen over when two machines are communicating over HTTP, how the message will be parsed, what sort of security aspects to employ when sending the message, etc., and these are then implemented by servers and clients ( usually web browsers ), using a programming language based on the infrastructure and needs. The choice of language, is independent, as HTTP specification is language agnostic.<!-- --></p>
<!-- --><p>So a server that, is able to speak the http protocol is called an HTTP Server.</p>
<!-- --><p>Examples of http servers are <!-- --><a href="https://www.nginx.com">nginx</a>, <!-- --><a href="http://www.apache.org">apache</a>, etc.<!-- --></p>
<!-- --><p>and similarly, a client which is able to speak the http protcol, is called an Http Client.</p>
<!-- --><p>Examples of http clients are <!-- --><a href="https://curl.haxx.se/">cURL</a> (command line http client), python <!-- --><a href="https://pypi.python.org/pypi/requests">requests</a> library and ofcourse web browsers.<!-- --></p>
<!-- --><p>Now with that explained, we are at the point to see some actual HTTP message.</p>
<!-- --><p>In HTTP, there are two parts of communication.
One is the request part, which is sent by http-clients, and the other is the response part, which is sent back by the servers on getting a http request.</p>
<!-- --><p>Now before we see any actual message, let us understand what a resource means in http.
Under HTTP, anything that we want to communicate to and fro or query for, with the remote machine is generally termed as a Resource.</p>
<!-- --><p>So lets see how, how do you say &#x27;hi&#x27; in http. (the request part of HTTP Communication)</p>
<!-- --><p>Before that, lets fire up a socket server in python over TCP, so that we can see what, http request mesage we are receiving from our browser(an http client). We will expand our server further to respond to our browser with a &#x27;hey hi client&#x27;, when the request is <!-- --><code>/hi</code> in part 2 of this post.<!-- --></p>
<!-- --><pre><code class="hljs language-python"><span class="hljs-keyword">import</span> socket

host,port = (<!-- --><span class="hljs-string">&#x27;&#x27;</span>,<!-- --><span class="hljs-number">1313</span>)

listener = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
listener.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,<!-- --><span class="hljs-number">1</span>)
listener.bind((host,port))
listener.listen(<!-- --><span class="hljs-number">1</span>)
<!-- --><span class="hljs-built_in">print</span>(<!-- --><span class="hljs-string">&quot;Serving on port {}&quot;</span>.<!-- --><span class="hljs-built_in">format</span>(port))
<!-- --><span class="hljs-keyword">while</span> <!-- --><span class="hljs-literal">True</span>:
    client_conn,client_addr = listener.accept()
    request = client_conn.recv(<!-- --><span class="hljs-number">1024</span>)
    <!-- --><span class="hljs-built_in">print</span> request 
<!-- --></code></pre>
<!-- --><p>We won&#x27;t be diving much into the details of the python sockets connection mechanism, to keep the blog focused only on HTTP. I intend to do another blog post on sockets. To put it in brief, sockets are endpoints of communcation, or channels,(technically its a tuple of (ip_address,port) ) that forms a pathway for messages to be sent accross remote entities.</p>
<!-- --><p>Save it as server.py, and do <!-- --><code>python server.py</code> to make it, start listening for requests on port 1313.<!-- --></p>
<!-- --><p>Now head over to the web browser, and put the url : <!-- --><code>localhost:1313/hi</code>.<!-- --></p>
<!-- --><p>Over your terminal window you will see something getting logged to standard output like this.</p>
<!-- --><pre><code class="hljs language-bash">GET /hi HTTP/1.1
Host: localhost:1313
Connection: keep-alive
Accept: text/html, application/xhtml, application/xml .... (omitted <!-- --><span class="hljs-keyword">for</span> brevity)
User-Agent: Mozilla/5.0 (Windows NT 6.3) .... (omitted <!-- --><span class="hljs-keyword">for</span> brevity)
Accept-Encoding: gzip, deflate,sdch
Accept-Language: en-US,en;q=0.8
Cookie: _ga=GA1.1.52864490.1449694093;__atuvc=27%7C7 ....
<!-- --></code></pre>
<!-- --><p>An http request starts a series of key value pairs, which in http parlance are known as <!-- --><code>header fields</code>.Basically each key value pair stores a metadata about our request, which is important to let the server know, like information about which http client it will be talking to and what resource is the client asking for and other details. I will touch on a few header fields here.<!-- --></p>
<!-- --><p>The first line is of our concern here:</p>
<!-- --><p><code>GET /hi HTTP/1.1</code></p>
<!-- --><p>This says that, it is a <!-- --><code>GET</code> request, and the path to our resource resides at <!-- --><code>/hi</code>, and next is the protcol that the client speaks which is <!-- --><code>HTTP/1.1</code>.<!-- --></p>
<!-- --><p>The next line tells about, the <!-- --><code>host</code>, which is <!-- --><code>localhost:1313</code>. It serves as the information to the server, where to send the resposne back to. <!-- --><code>localhost</code> is our domain,<!-- --><code>1313</code>, is our port number on which the server is listening to.<!-- --></p>
<!-- --><p>Note: Now web servers by convention, listen on port 80</p>
<!-- --><p>Now before we talk about the next line, we need to know about the term <!-- --><code>stateless</code>. As HTTP is a stateless protocol, each request and response cycle is not dependent on any previous request reponse. Every response that is made, is ignorant of the state of the server, or any previous request that was sent. I intend to have another blog post on stateless property of HTTP, so for the time being lets, keep it to this definition.<!-- --></p>
<!-- --><p>So the <!-- --><code>Connection: keep-alive</code> says, that we want to reuse the same tcp connection we established on the request, for further requests. As HTTP is stateless it closes the connection after every request it makes and so for every subsequent request, HTTP has to re-establish connection to the server.
If this header field is present, this will try to minimize the the overhead of re-establising the tcp connection on further request. The time for connection keep alive, is usually specified when implementing the server, and also can be configured.<!-- --></p>
<!-- --><p>The <!-- --><code>User-Agent</code> header serves as another identity mechanism, to send different, representations of response message to the user. In this example, the user-agent is a Web browser. A mobile device will send a user agent ( for example <!-- --><code>Apple-iPhone4C1/902.206</code> is the user agent for an Apple iPhone4C ); that is different from a web browser becuase its different in terms of form factor, and various features. So accordingly that wil be served differently by the web server.<!-- --></p>
<!-- --><p>For further information on other fields, i would reference the sections on the RFC for HTTP1.1, as it is explained better, and it will also help you to get more into reading RFC&#x27;s directly, and get familiar with their struture and how to make meaning out of them.</p>
<!-- --><p><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3">Accept-Encoding</a></p>
<!-- --><p><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4">Accept-Language</a></p>
<!-- --><p><a href="https://tools.ietf.org/html/rfc6265#section-4.2">Cookie</a></p>
<!-- --><p>In the next part of this post, we will look over the other side of HTTP, i.e., the Response. We will parse the first line of header field of our request, and will send a response back to the browser.</p>
<!-- --><p>Until next time!</p><div class="flex justify-center"><hr class="mb-8 h-px bg-gray-400 border-0 dark:bg-gray-500 w-full"/></div><p class="text-sm font-bold">Want to share feedback, or discuss further ideas? Feel free to leave a comment here! Please follow Rust&#x27;s code of conduct. This comment thread directly maps to a discussion on GitHub, so you can also comment there if you prefer.</p></article>;<!-- --></div><footer class="flex flex-col items-center w-full"><div class="px-4 py-2 flex items-center justify-center space-x-2 border-2 rounded-md border-gray-500 hover:bg-blue-100 transition-colors hover:text-lime-900"><svg stroke="currentColor" fill="currentColor" stroke-width="0" role="img" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><title></title><path d="M17.625 1.499c-2.32 0-4.354 1.203-5.625 3.03-1.271-1.827-3.305-3.03-5.625-3.03C3.129 1.499 0 4.253 0 8.249c0 4.275 3.068 7.847 5.828 10.227a33.14 33.14 0 0 0 5.616 3.876l.028.017.008.003-.001.003c.163.085.342.126.521.125.179.001.358-.041.521-.125l-.001-.003.008-.003.028-.017a33.14 33.14 0 0 0 5.616-3.876C20.932 16.096 24 12.524 24 8.249c0-3.996-3.129-6.75-6.375-6.75zm-.919 15.275a30.766 30.766 0 0 1-4.703 3.316l-.004-.002-.004.002a30.955 30.955 0 0 1-4.703-3.316c-2.677-2.307-5.047-5.298-5.047-8.523 0-2.754 2.121-4.5 4.125-4.5 2.06 0 3.914 1.479 4.544 3.684.143.495.596.797 1.086.796.49.001.943-.302 1.085-.796.63-2.205 2.484-3.684 4.544-3.684 2.004 0 4.125 1.746 4.125 4.5 0 3.225-2.37 6.216-5.048 8.523z"></path></svg><p>Be a GitHub Sponser</p></div><div class="flex-col items-center justify-center mt-8 mb-8"><div class="text-center text-xs mx-auto">© 2016-<!-- -->2022<!-- --> creativcoder. All rights reserved.<!-- --></div></div></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    a: \"a\",\n    code: \"code\",\n    pre: \"pre\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://images.unsplash.com/photo-1531765408077-9a1f85f90df1?ixlib=rb-4.0.3\u0026ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8\u0026auto=format\u0026fit=crop\u0026w=1173\u0026q=80\",\n        alt: \"cover image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I have seen many of my peers ask from time to time, what is http, and how it works.\\nAlso as a web developer understanding HTTP protocol is an essential asset to be able to think in a way, as to how to architecture your web apps, so that it follows the semantics of HTTP.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This post will discuss on the abstraction/medium on which the 'user facing' internet stands on.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"A bit of background first!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Similar to how we as humans need a language with a structure to communicate and exchange ideas effectively among our peers; computers need to talk to different computers over a network. And being dumb machines, they need every detail communicated in the message in a precise manner.\\nHTTP is just that language through which computers can talk to other remote computers over a network.\\nTechnically speaking, HTTP is a request/response based, stateless (will come to this on a follow up post) application layer protocol, implemented on top of a stateful protcol which is TCP/IP usually.\\nTCP/IP is another lower layer of abstraction for communicating bytes reliably over the network.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In the same way how our english sentences have a formal structure and semantic; the HTTP protocol also has a formal description of it, usually defined in a spec sheet, called \", _jsx(_components.a, {\n        href: \"https://www.ietf.org/rfc.html\",\n        children: \"RFC\"\n      }), \"'s (Request for Comments).\\nThese are standardized documents, that are accepted globally and maintained by IETF(Internet Engineering Task Force).\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The HTTP's \", _jsx(_components.a, {\n        href: \"https://www.rfc-editor.org/rfc/rfc2616.txt\",\n        children: \"RFC\"\n      }), \" describes in details, every aspect of the request reponse cycle, that can happen over when two machines are communicating over HTTP, how the message will be parsed, what sort of security aspects to employ when sending the message, etc., and these are then implemented by servers and clients ( usually web browsers ), using a programming language based on the infrastructure and needs. The choice of language, is independent, as HTTP specification is language agnostic.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So a server that, is able to speak the http protocol is called an HTTP Server.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Examples of http servers are \", _jsx(_components.a, {\n        href: \"https://www.nginx.com\",\n        children: \"nginx\"\n      }), \", \", _jsx(_components.a, {\n        href: \"http://www.apache.org\",\n        children: \"apache\"\n      }), \", etc.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"and similarly, a client which is able to speak the http protcol, is called an Http Client.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Examples of http clients are \", _jsx(_components.a, {\n        href: \"https://curl.haxx.se/\",\n        children: \"cURL\"\n      }), \" (command line http client), python \", _jsx(_components.a, {\n        href: \"https://pypi.python.org/pypi/requests\",\n        children: \"requests\"\n      }), \" library and ofcourse web browsers.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now with that explained, we are at the point to see some actual HTTP message.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In HTTP, there are two parts of communication.\\nOne is the request part, which is sent by http-clients, and the other is the response part, which is sent back by the servers on getting a http request.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now before we see any actual message, let us understand what a resource means in http.\\nUnder HTTP, anything that we want to communicate to and fro or query for, with the remote machine is generally termed as a Resource.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So lets see how, how do you say 'hi' in http. (the request part of HTTP Communication)\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Before that, lets fire up a socket server in python over TCP, so that we can see what, http request mesage we are receiving from our browser(an http client). We will expand our server further to respond to our browser with a 'hey hi client', when the request is \", _jsx(_components.code, {\n        children: \"/hi\"\n      }), \" in part 2 of this post.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" socket\\n\\nhost,port = (\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"''\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1313\"\n        }), \")\\n\\nlistener = socket.socket(socket.AF_INET,socket.SOCK_STREAM)\\nlistener.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")\\nlistener.bind((host,port))\\nlistener.listen(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Serving on port {}\\\"\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"format\"\n        }), \"(port))\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"True\"\n        }), \":\\n    client_conn,client_addr = listener.accept()\\n    request = client_conn.recv(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1024\"\n        }), \")\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \" request \\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We won't be diving much into the details of the python sockets connection mechanism, to keep the blog focused only on HTTP. I intend to do another blog post on sockets. To put it in brief, sockets are endpoints of communcation, or channels,(technically its a tuple of (ip_address,port) ) that forms a pathway for messages to be sent accross remote entities.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Save it as server.py, and do \", _jsx(_components.code, {\n        children: \"python server.py\"\n      }), \" to make it, start listening for requests on port 1313.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now head over to the web browser, and put the url : \", _jsx(_components.code, {\n        children: \"localhost:1313/hi\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Over your terminal window you will see something getting logged to standard output like this.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-bash\",\n        children: [\"GET /hi HTTP/1.1\\nHost: localhost:1313\\nConnection: keep-alive\\nAccept: text/html, application/xhtml, application/xml .... (omitted \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" brevity)\\nUser-Agent: Mozilla/5.0 (Windows NT 6.3) .... (omitted \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" brevity)\\nAccept-Encoding: gzip, deflate,sdch\\nAccept-Language: en-US,en;q=0.8\\nCookie: _ga=GA1.1.52864490.1449694093;__atuvc=27%7C7 ....\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"An http request starts a series of key value pairs, which in http parlance are known as \", _jsx(_components.code, {\n        children: \"header fields\"\n      }), \".Basically each key value pair stores a metadata about our request, which is important to let the server know, like information about which http client it will be talking to and what resource is the client asking for and other details. I will touch on a few header fields here.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The first line is of our concern here:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"GET /hi HTTP/1.1\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This says that, it is a \", _jsx(_components.code, {\n        children: \"GET\"\n      }), \" request, and the path to our resource resides at \", _jsx(_components.code, {\n        children: \"/hi\"\n      }), \", and next is the protcol that the client speaks which is \", _jsx(_components.code, {\n        children: \"HTTP/1.1\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The next line tells about, the \", _jsx(_components.code, {\n        children: \"host\"\n      }), \", which is \", _jsx(_components.code, {\n        children: \"localhost:1313\"\n      }), \". It serves as the information to the server, where to send the resposne back to. \", _jsx(_components.code, {\n        children: \"localhost\"\n      }), \" is our domain,\", _jsx(_components.code, {\n        children: \"1313\"\n      }), \", is our port number on which the server is listening to.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Note: Now web servers by convention, listen on port 80\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now before we talk about the next line, we need to know about the term \", _jsx(_components.code, {\n        children: \"stateless\"\n      }), \". As HTTP is a stateless protocol, each request and response cycle is not dependent on any previous request reponse. Every response that is made, is ignorant of the state of the server, or any previous request that was sent. I intend to have another blog post on stateless property of HTTP, so for the time being lets, keep it to this definition.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So the \", _jsx(_components.code, {\n        children: \"Connection: keep-alive\"\n      }), \" says, that we want to reuse the same tcp connection we established on the request, for further requests. As HTTP is stateless it closes the connection after every request it makes and so for every subsequent request, HTTP has to re-establish connection to the server.\\nIf this header field is present, this will try to minimize the the overhead of re-establising the tcp connection on further request. The time for connection keep alive, is usually specified when implementing the server, and also can be configured.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"User-Agent\"\n      }), \" header serves as another identity mechanism, to send different, representations of response message to the user. In this example, the user-agent is a Web browser. A mobile device will send a user agent ( for example \", _jsx(_components.code, {\n        children: \"Apple-iPhone4C1/902.206\"\n      }), \" is the user agent for an Apple iPhone4C ); that is different from a web browser becuase its different in terms of form factor, and various features. So accordingly that wil be served differently by the web server.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For further information on other fields, i would reference the sections on the RFC for HTTP1.1, as it is explained better, and it will also help you to get more into reading RFC's directly, and get familiar with their struture and how to make meaning out of them.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\",\n        children: \"Accept-Encoding\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4\",\n        children: \"Accept-Language\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://tools.ietf.org/html/rfc6265#section-4.2\",\n        children: \"Cookie\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In the next part of this post, we will look over the other side of HTTP, i.e., the Response. We will parse the first line of header field of our request, and will send a response back to the browser.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Until next time!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"meta":{"excerpt":"","slug":"understanding-the-http-protocol-part-1","title":"Understanding the HTTP Protocol in simple terms: Part 1","tags":["fundamentals","http","protocol"],"date":"Tue Feb 16 2016 05:30:00 GMT+0530 (India Standard Time)","author":"creativcoder","readingTime":"6min"}}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"understanding-the-http-protocol-part-1"},"buildId":"C0oqtusQj9cY-EdwLN_RL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>