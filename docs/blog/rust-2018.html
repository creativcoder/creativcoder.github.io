<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>creativcoder</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/ab2a2959b9ba8661.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ab2a2959b9ba8661.css" data-n-g=""/><link rel="preload" href="/_next/static/css/f16eaa9e44b97d3f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f16eaa9e44b97d3f.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-9faa89de3ee6e754.js" defer=""></script><script src="/_next/static/chunks/framework-a87821de553db91d.js" defer=""></script><script src="/_next/static/chunks/main-32a43e1092778ede.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2e588ff4f55f23af.js" defer=""></script><script src="/_next/static/chunks/167-4ae4480dee839e87.js" defer=""></script><script src="/_next/static/chunks/675-f43734e7770ea31e.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-c606869ed04a3d0b.js" defer=""></script><script src="/_next/static/C0oqtusQj9cY-EdwLN_RL/_buildManifest.js" defer=""></script><script src="/_next/static/C0oqtusQj9cY-EdwLN_RL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="" style="position:fixed;top:0;left:0;height:3px;background:transparent;z-index:99999999999;width:100%"><div class="" style="height:100%;background:#4CE0B3;transition:all 500ms ease;width:0%"><div style="box-shadow:0 0 10px #4CE0B3, 0 0 10px #4CE0B3;width:5%;opacity:1;position:absolute;height:100%;transition:all 500ms ease;transform:rotate(3deg) translate(0px, -4px);left:-10rem"></div></div></div><div class="flex min-h-screen w-screen overflow-hidden flex-col items-center dark:bg-[#242729] bg-slate-200 backdrop" style="opacity:0.5;background-color:#E2E8F0"><div class="max-w-2xl md:max-w-3xl lg:max-w-4xl space-y-12 w-screen sticky"><nav class="bg-[#f6f8f9] dark:bg-[#2b2e30] dark:shadow-md m-3 rounded-lg shadow-sm backdrop-filter backdrop-blur-md bg-opacity-40 sticky top-0 mt-10"><div class="mx-auto p-4"><div class="flex justify-between"><div class="cursor-pointer flex space-x-2 items-center"><div><img src="/logo_v3.svg" width="26" class="pt-0.5 invert"/></div><div class="text-lg dark:text-white hidden md:block">creativcoder</div></div><div class="flex items-center pr-2"><ul class="hidden md:flex md:space-x-4 pr-3"><a class="hover:text-slate-500 dark:text-slate-200 text-slate-700 transition flex items-center" href="/blog"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M18.404 2.998c-.757-.754-2.077-.751-2.828.005l-1.784 1.791L11.586 7H7a.998.998 0 0 0-.939.658l-4 11c-.133.365-.042.774.232 1.049l2 2a.997.997 0 0 0 1.049.232l11-4A.998.998 0 0 0 17 17v-4.586l2.207-2.207v-.001h.001L21 8.409c.378-.378.586-.881.585-1.415 0-.535-.209-1.038-.588-1.415l-2.593-2.581zm-3.111 8.295A.996.996 0 0 0 15 12v4.3l-9.249 3.363 4.671-4.671c.026.001.052.008.078.008A1.5 1.5 0 1 0 9 13.5c0 .026.007.052.008.078l-4.671 4.671L7.7 9H12c.266 0 .52-.105.707-.293L14.5 6.914 17.086 9.5l-1.793 1.793zm3.206-3.208-2.586-2.586 1.079-1.084 2.593 2.581-1.086 1.089z"></path></svg></a><a class="hover:text-slate-500 dark:text-slate-200 text-slate-700 transition flex items-center" href="https://youtube.com/@creativcoder"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="24" width="24" xmlns="http://www.w3.org/2000/svg"><g><path fill="none" d="M0 0h24v24H0z"></path><path fill-rule="nonzero" d="M19.606 6.995c-.076-.298-.292-.523-.539-.592C18.63 6.28 16.5 6 12 6s-6.628.28-7.069.403c-.244.068-.46.293-.537.592C4.285 7.419 4 9.196 4 12s.285 4.58.394 5.006c.076.297.292.522.538.59C5.372 17.72 7.5 18 12 18s6.629-.28 7.069-.403c.244-.068.46-.293.537-.592C19.715 16.581 20 14.8 20 12s-.285-4.58-.394-5.005zm1.937-.497C22 8.28 22 12 22 12s0 3.72-.457 5.502c-.254.985-.997 1.76-1.938 2.022C17.896 20 12 20 12 20s-5.893 0-7.605-.476c-.945-.266-1.687-1.04-1.938-2.022C2 15.72 2 12 2 12s0-3.72.457-5.502c.254-.985.997-1.76 1.938-2.022C6.107 4 12 4 12 4s5.896 0 7.605.476c.945.266 1.687 1.04 1.938 2.022zM10 15.5v-7l6 3.5-6 3.5z"></path></g></svg></a><a class="hover:text-slate-500 dark:text-slate-200 text-slate-700 transition flex items-center" href="/about"><svg stroke="currentColor" fill="none" stroke-width="0" viewBox="0 0 24 24" height="24" width="24" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M16 9C16 11.2091 14.2091 13 12 13C9.79086 13 8 11.2091 8 9C8 6.79086 9.79086 5 12 5C14.2091 5 16 6.79086 16 9ZM14 9C14 10.1046 13.1046 11 12 11C10.8954 11 10 10.1046 10 9C10 7.89543 10.8954 7 12 7C13.1046 7 14 7.89543 14 9Z" fill="currentColor"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1ZM3 12C3 14.0902 3.71255 16.014 4.90798 17.5417C6.55245 15.3889 9.14627 14 12.0645 14C14.9448 14 17.5092 15.3531 19.1565 17.4583C20.313 15.9443 21 14.0524 21 12C21 7.02944 16.9706 3 12 3C7.02944 3 3 7.02944 3 12ZM12 21C9.84977 21 7.87565 20.2459 6.32767 18.9878C7.59352 17.1812 9.69106 16 12.0645 16C14.4084 16 16.4833 17.1521 17.7538 18.9209C16.1939 20.2191 14.1881 21 12 21Z" fill="currentColor"></path></svg></a></ul><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="md:hidden block"><path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path></svg></div></div></div></nav><div><article class="dark:text-slate-200 dark:prose-headings:text-slate-200 dark:prose-code:text-slate-200 dark:prose-blockquote:text-slate-200 dark:prose-strong:text-slate-100 dark:prose-pre:bg-zinc-900 dark:prose-pre:shadow-md dark:prose-pre:border-gray-600 dark:prose-pre:border-[1.4px] dark:prose-a:text-slate-200 prose prose-xl flex flex-col mx-auto max-w-6xl justify-center pl-6 pr-6 prose-p:m-3 prose-headings:mb-3 prose-headings:mt-3 prose-a:font-bold prose-img:rounded-lg prose-img:m-auto prose-img:w-full prose-img:shadow-lg prose-code:font-jetbrains prose-pre:p-0 prose-a:no-underline prose-h1:text-4xl prose-h1:pl-2 prose-h2:pl-2 prose-blockquote:border-slate-600 prose-h2:text-xl"><div class="flex flex-col"><p class="text-4xl font-bold">Making Rust more awesome in 2018 - My wishlist</p><div class="pt-3 flex justify-between flex-row-reverse"><div class="flex items-center space-x-2"><p class="text-sm">20th January 2018</p></div><div class="flex items-center space-x-2"><p class="text-sm tracking-wide"> / <!-- -->6min<!-- --></p></div></div><div class="flex justify-center"><hr class="mb-8 h-px bg-gray-400 border-0 dark:bg-gray-500 w-full"/></div></div><p>ðŸ‘‡ Is how I feel using Rust in 2018!
ðŸ˜‚</p>
<!-- --><p><img src="https://mir-s3-cdn-cf.behance.net/project_modules/disp/7df0bd42774743.57ee5f32bd76e.gif" alt="Dancing Ferris" title="Logo Title Text 1"/>
Credits for the animated ferris/header image goes to http://www.rustacean.net/<!-- --><br/></p>
<!-- --><p>Rustaceans may already be familiar with <!-- --><a href="http://readrust.net/rust2018/">Read Rust 2018</a>. It&#x27;s really awesome to see all blog posts by other people. I&#x27;m yet to finish reading all of them :P<!-- --><br/></p>
<!-- --><p>Adding to the chain of wishlist and suggestions for Rust&#x27;s roadmap for 2018, here&#x27;s my <!-- --><strong>wishlist</strong>:<!-- --></p>
<!-- --><h3 id="building-trust-in-using-rust-for-safety-critical-applications"><a href="#building-trust-in-using-rust-for-safety-critical-applications">Building trust in using Rust for safety-critical applications</a></h3>
<!-- --><p>The efforts on frameworks such as <!-- --><code>tokio</code>, <!-- --><code>futures</code>, and  backend targets such as <!-- --><code>wasm</code> is greatly appreciated. The real use case however, where Rust is really needed is in IOT/Embedded space.<!-- --><br/></p>
<!-- --><p>Thoughts on why I think so:</p>
<!-- --><p>The embedded systems domain is mostly dominated by C.
Now with C compilers&#x27; assumptive behaviour and the various undefined behaviour that you can cause with it, organizations had to come up with coding standards like (<!-- --><a href="https://en.wikipedia.org/wiki/MISRA_C">MISRA_C in automotive industry</a>) to ensure reliability/safety in such applications.<!-- --></p>
<!-- --><p>With Rust; those guidelines mentioned in these standards are mostly covered because of the guarantees provided by the type system (except the case when doing FFI). Rust would be way more valued in embedded world. In 2018, it is time that the community make efforts to curate good quality crates for embedded/IOT space.</p>
<!-- --><p>Currenly few people are involved in progressing the story of Rust on microcontrollers. A big shout-out to <!-- --><a href="https://github.com/japaric"><code>japaric</code></a> for his contributions in this space. Currently his focus are on ARM Cortex-M microcontrollers. There are already good quality crates <!-- --><a href="https://github.com/japaric/embedded-hal">embedded-hal</a>, <!-- --><a href="https://github.com/japaric/f3">f3</a>, <!-- --><a href="https://github.com/japaric/cortex-m-quickstart">cortex-m-quickstart</a>; we need more like them for other platforms too. We need more people writing about using Rust for microcontrollers this year. To make people aware on current state of things in this space, meetups can organize hardware hacking sessions using Rust and encourage them to contribute to related crates. Rust should really be the recommended language for IOT based products and embedded systems. I would like to link the discussion thread for this made by <!-- --><code>japaric</code>: <!-- --><a href="https://users.rust-lang.org/t/rust-for-embedded-development-where-we-are-and-whats-missing/10861">Rust for embedded-dev, where are we and what&#x27;s missing</a></p>
<!-- --><p>Also, I don&#x27;t know much about the current state of things in formal verification of the language; but would like to see activity/progress being made in that area too. There is one by <!-- --><a href="https://people.mpi-sws.org/~dreyer/papers/rustbelt/paper.pdf">Ralf Jung</a>. It is also desired that the language team progresses towards a standard specification of the language, similar to standards like ECMA standard and C++ ISO standard.<!-- --></p>
<!-- --><h3 id="on-async-io"><a href="#on-async-io">On Async I/O</a></h3>
<!-- --><p>I would also like to see <!-- --><a href="https://github.com/alexcrichton/futures-await">async-await</a> sugars to be usable on stable Rust this year. Also a cookbook explaining future and tokio abstractions would be appreciated. I also feel that the <!-- --><code>futures</code> crate could be improved on error messages. Having worked with it, I feel the error messages are unreadable and sometimes diametric. For example:<!-- --></p>
<!-- --><pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <!-- --><span class="hljs-title function_">main</span>() {
    <!-- --><span class="hljs-keyword">let</span> <!-- --><span class="hljs-keyword"></span><span class="hljs-variable">ok_future</span> = ok::&lt;_,()&gt;(());
    <!-- --><span class="hljs-keyword">let</span> <!-- --><span class="hljs-keyword"></span><span class="hljs-variable">composed</span> = ok_future.<!-- --><span class="hljs-title function_ invoke__">then</span>(|e| {
        ok::&lt;_,()&gt;(<!-- --><span class="hljs-literal">true</span>)
    });

    <!-- --><span class="hljs-keyword">let</span> <!-- --><span class="hljs-keyword">mut </span><span class="hljs-variable">core</span> = Core::<!-- --><span class="hljs-title function_ invoke__">new</span>().<!-- --><span class="hljs-title function_ invoke__">unwrap</span>();
    <!-- --><span class="hljs-keyword">let</span> <!-- --><span class="hljs-keyword"></span><span class="hljs-variable">handle</span> = core.<!-- --><span class="hljs-title function_ invoke__">handle</span>();
    handle.<!-- --><span class="hljs-title function_ invoke__">spawn</span>(composed);
}
<!-- --></code></pre>
<!-- --><p>reports error as :</p>
<!-- --><pre><code class="hljs language-rust"><span class="hljs-keyword">type</span> <!-- --><span class="hljs-title class_">mismatch</span> resolving `&lt;futures::Join&lt;futures::Then&lt;futures::FutureResult&lt;(), ()&gt;, futures::FutureResult&lt;<!-- --><span class="hljs-type">bool</span>, ()&gt;, [closure@src/main.rs:<!-- --><span class="hljs-number">14</span>:<!-- --><span class="hljs-number">35</span>: <!-- --><span class="hljs-number">16</span>:<!-- --><span class="hljs-number">6</span>]&gt;, futures::FutureResult&lt;<!-- --><span class="hljs-type">u32</span>, ()&gt;&gt; <!-- --><span class="hljs-keyword">as</span> futures::Future&gt;::Item == ()`
  -<!-- --><span class="hljs-punctuation">-&gt;</span> src/main.rs:<!-- --><span class="hljs-number">21</span>:<!-- --><span class="hljs-number">12</span>
   |
<!-- --><span class="hljs-number">21</span> |     handle.<!-- --><span class="hljs-title function_ invoke__">spawn</span>(joined);
   |            ^^^^^ expected <!-- --><span class="hljs-type">bool</span>, <!-- --><span class="hljs-title function_ invoke__">found</span> ()
   |
   = note: expected <!-- --><span class="hljs-keyword">type</span> `<!-- --><span class="hljs-type">bool</span>`
              found <!-- --><span class="hljs-keyword">type</span> `()`
<!-- --></code></pre>
<!-- --><p>Ideally, the error message given by compiler should be the other way around i.e.,
It should report:
<!-- --><code>the expected type is (), but found type is bool.</code></p>
<!-- --><p>It&#x27;s easy to figure out the issue on your own in trivial cases like above, but becomes difficul to reason about when complex return types are involved. Also the verbose representation of composed futures type in &quot;<!-- --><code>type mismatch ...</code>&quot; statement above here can be shortened; I don&#x27;t know, maybe by compiler plugins. For a new comer, these errors become overwhelming and gives an impression that the library is hard to work with. Also for returning futures we really need the <!-- --><a href="https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md">impl trait RFC</a> to land on stable as most of the time we need to return boxes of futures which adds overhead.<!-- --></p>
<!-- --><h3 id="syntax-enhancements"><a href="#syntax-enhancements">Syntax enhancements:</a></h3>
<!-- --><p><strong>Small things</strong>:
Similar to what we have for <!-- --><code>vec![]</code> provided by the <!-- --><a href="https://doc.rust-lang.org/std/macro.vec.html">standard library</a>, other container types can also benefit from shorthands  implemented as macros like <!-- --><code>map!{}</code>, <!-- --><code>bmap!{}</code>, <!-- --><code>set!{}</code>. There are already macro <!-- --><a href="https://docs.rs/maplit/1.0.2/maplit/">crates</a> for doing this but the standard library can already provide them just like it has for vec![]. The fact that these crates exist outside the offical ecosystem means that there&#x27;s a use case for it. These are small things but can greatly improve coding experience.<!-- --></p>
<!-- --><p><strong>Idea of data structs/classes</strong> - This is taken from Kotlin&#x27;s <!-- --><a href="https://kotlinlang.org/docs/reference/data-classes.html">data classes</a>, where you can prefix a class with <!-- --><code>data</code> keyword and your class automatically gets a default all parameter constructors and getters and setters too. In Rust, this can translate to a <!-- --><code>#[derive(new, getter, setter)]</code> or a <!-- --><code>#[derive(DataStruct)]</code> on top of struct or enum declarations. There are times we just want to have bunch of fields together in a struct and just access or set them later. This abstraction can become really handy in minimizing boilerplate code.<!-- --></p>
<!-- --><p><strong>String template literals</strong>: It becomes quite verbose to use <!-- --><code>format!(&quot;Foo{}&quot;,&quot;Bar&quot;)</code> everytime we want to use interpolated strings. Something like <!-- --><code>\`Foo{bar}\</code> will be awesome if possible. There have been discussion on <!-- --><a href="https://mail.mozilla.org/pipermail/rust-dev/2012-February/001346.html">this</a> and also an issue <!-- --><a href="https://github.com/rust-lang/rfcs/issues/1250">#1250</a>. Also slice patterns like <!-- --><code>let &amp;[a,b,_,_,_] = &amp;[1,2,3,4,5]</code> should be stable.<!-- --></p>
<!-- --><p><strong>Default argument methods</strong> - Methods with default arguments eliminate the need to provide a seperate set method on structs. Relevant issue <!-- --><a href="https://github.com/rust-lang/rfcs/issues/323">#323</a>. There are many others and would possibly make this post long if I list here.<!-- --></p>
<!-- --><h3 id="on-tooling-and-infrastructure"><a href="#on-tooling-and-infrastructure">On tooling and infrastructure:</a></h3>
<!-- --><p>I want to talk about the cross compilation tooling. There is <!-- --><a href="https://github.com/japaric/xargo">xargo</a> which makes it easy to pull source of Rust&#x27;s standard library and helps to cross compile crates to other
platforms. xargo&#x27;s functionality just be integrated within cargo itself. This will make cargo more versatile tool on the cross compilation space.<!-- --></p>
<!-- --><h3 id="guides-for-intermediate-programmers"><a href="#guides-for-intermediate-programmers">Guides for intermediate programmers</a></h3>
<!-- --><p>Last year the community made efforts for curating newbies to Rust. This year should be for intermediate rustaceans who want to upgrade their Rust skills. We want better examples/patterns/cookbook describing when lifetime annotations are really necessary in code. Guides on using the type systems well to encode semantics at compile time into the program. Tutorials on implementing non-trivial data structures and container types and how it compares to other languages. There is already a beautiful one by <!-- --><a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">alexis</a> but we need more like that.<!-- --></p>
<!-- --><h3 id="tooling-for-benchmarking-profiling-rust-programs"><a href="#tooling-for-benchmarking-profiling-rust-programs">Tooling for Benchmarking, profiling Rust programs</a></h3>
<!-- --><p>The profiling story also needs to improve this year. There have been good efforts to integrate existing tools within cargo such as <!-- --><a href="https://github.com/kernelmachine/cargo-profiler">cargo-profiler</a> but they need to support Windows and macOS as well.<!-- --></p>
<!-- --><h3 id="more-macro-guides"><a href="#more-macro-guides">More macro guides</a></h3>
<!-- --><p>Macros are really useful but the complex ones are harder to write for newbies. To encourage more people to use it, I would like to see a dedicated book for macros for coding idioms and best practices/gotchas for intermediate programmers. These days crates seem to be using macros heavily (looking at <!-- --><a href="https://rocket.rs/"><code>rocket</code></a>) and someone attempting to understand and contribute to the macro code has to patiently read the cryptic patterns or even experiment the macro code in isolation to make sense of what it is actually doing. Blog post like Julia&#x27;s <!-- --><a href="https://jvns.ca/blog/2017/12/24/my-first-rust-macro/">post</a> are really appreciated.<!-- --></p>
<!-- --><h3 id="bringing-more-people-to-rust-compiler-hacking"><a href="#bringing-more-people-to-rust-compiler-hacking">Bringing more people to Rust compiler hacking</a></h3>
<!-- --><p>This <!-- --><a href="https://internals.rust-lang.org/t/so-you-want-to-hack-on-the-rust-compiler-a-plan-for-a-book/6497">post</a> really got me excited. With such efforts Rust community is making great strides in democratizing the knowledge of systems programming topics such as compilers, operating systems, garbage collectors, and other low level concepts to the masses which before, was only limited to a few wizards. A big shoutout to <!-- --><a href="https://github.com/nikomatsakis"><code>niko</code></a> and compiler team for progressing this in 2018.<!-- --></p>
<!-- --><p>Will close it here today, wish you all a happy new year! :)</p><div class="flex justify-center"><hr class="mb-8 h-px bg-gray-400 border-0 dark:bg-gray-500 w-full"/></div><p class="text-sm font-bold">Want to share feedback, or discuss further ideas? Feel free to leave a comment here! Please follow Rust&#x27;s code of conduct. This comment thread directly maps to a discussion on GitHub, so you can also comment there if you prefer.</p></article>;<!-- --></div><footer class="flex flex-col items-center w-full"><div class="px-4 py-2 flex items-center justify-center space-x-2 border-2 rounded-md border-gray-500 hover:bg-blue-100 transition-colors hover:text-lime-900"><svg stroke="currentColor" fill="currentColor" stroke-width="0" role="img" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><title></title><path d="M17.625 1.499c-2.32 0-4.354 1.203-5.625 3.03-1.271-1.827-3.305-3.03-5.625-3.03C3.129 1.499 0 4.253 0 8.249c0 4.275 3.068 7.847 5.828 10.227a33.14 33.14 0 0 0 5.616 3.876l.028.017.008.003-.001.003c.163.085.342.126.521.125.179.001.358-.041.521-.125l-.001-.003.008-.003.028-.017a33.14 33.14 0 0 0 5.616-3.876C20.932 16.096 24 12.524 24 8.249c0-3.996-3.129-6.75-6.375-6.75zm-.919 15.275a30.766 30.766 0 0 1-4.703 3.316l-.004-.002-.004.002a30.955 30.955 0 0 1-4.703-3.316c-2.677-2.307-5.047-5.298-5.047-8.523 0-2.754 2.121-4.5 4.125-4.5 2.06 0 3.914 1.479 4.544 3.684.143.495.596.797 1.086.796.49.001.943-.302 1.085-.796.63-2.205 2.484-3.684 4.544-3.684 2.004 0 4.125 1.746 4.125 4.5 0 3.225-2.37 6.216-5.048 8.523z"></path></svg><p>Be a GitHub Sponser</p></div><div class="flex-col items-center justify-center mt-8 mb-8"><div class="text-center text-xs mx-auto">Â© 2016-<!-- -->2022<!-- --> creativcoder. All rights reserved.<!-- --></div></div></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    a: \"a\",\n    strong: \"strong\",\n    h3: \"h3\",\n    code: \"code\",\n    pre: \"pre\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"ðŸ‘‡ Is how I feel using Rust in 2018!\\nðŸ˜‚\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.img, {\n        src: \"https://mir-s3-cdn-cf.behance.net/project_modules/disp/7df0bd42774743.57ee5f32bd76e.gif\",\n        alt: \"Dancing Ferris\",\n        title: \"Logo Title Text 1\"\n      }), \"\\nCredits for the animated ferris/header image goes to http://www.rustacean.net/\", _jsx(\"br\", {})]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Rustaceans may already be familiar with \", _jsx(_components.a, {\n        href: \"http://readrust.net/rust2018/\",\n        children: \"Read Rust 2018\"\n      }), \". It's really awesome to see all blog posts by other people. I'm yet to finish reading all of them :P\", _jsx(\"br\", {})]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Adding to the chain of wishlist and suggestions for Rust's roadmap for 2018, here's my \", _jsx(_components.strong, {\n        children: \"wishlist\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"building-trust-in-using-rust-for-safety-critical-applications\",\n      children: _jsx(_components.a, {\n        href: \"#building-trust-in-using-rust-for-safety-critical-applications\",\n        children: \"Building trust in using Rust for safety-critical applications\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The efforts on frameworks such as \", _jsx(_components.code, {\n        children: \"tokio\"\n      }), \", \", _jsx(_components.code, {\n        children: \"futures\"\n      }), \", and  backend targets such as \", _jsx(_components.code, {\n        children: \"wasm\"\n      }), \" is greatly appreciated. The real use case however, where Rust is really needed is in IOT/Embedded space.\", _jsx(\"br\", {})]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Thoughts on why I think so:\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The embedded systems domain is mostly dominated by C.\\nNow with C compilers' assumptive behaviour and the various undefined behaviour that you can cause with it, organizations had to come up with coding standards like (\", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/MISRA_C\",\n        children: \"MISRA_C in automotive industry\"\n      }), \") to ensure reliability/safety in such applications.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"With Rust; those guidelines mentioned in these standards are mostly covered because of the guarantees provided by the type system (except the case when doing FFI). Rust would be way more valued in embedded world. In 2018, it is time that the community make efforts to curate good quality crates for embedded/IOT space.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Currenly few people are involved in progressing the story of Rust on microcontrollers. A big shout-out to \", _jsx(_components.a, {\n        href: \"https://github.com/japaric\",\n        children: _jsx(_components.code, {\n          children: \"japaric\"\n        })\n      }), \" for his contributions in this space. Currently his focus are on ARM Cortex-M microcontrollers. There are already good quality crates \", _jsx(_components.a, {\n        href: \"https://github.com/japaric/embedded-hal\",\n        children: \"embedded-hal\"\n      }), \", \", _jsx(_components.a, {\n        href: \"https://github.com/japaric/f3\",\n        children: \"f3\"\n      }), \", \", _jsx(_components.a, {\n        href: \"https://github.com/japaric/cortex-m-quickstart\",\n        children: \"cortex-m-quickstart\"\n      }), \"; we need more like them for other platforms too. We need more people writing about using Rust for microcontrollers this year. To make people aware on current state of things in this space, meetups can organize hardware hacking sessions using Rust and encourage them to contribute to related crates. Rust should really be the recommended language for IOT based products and embedded systems. I would like to link the discussion thread for this made by \", _jsx(_components.code, {\n        children: \"japaric\"\n      }), \": \", _jsx(_components.a, {\n        href: \"https://users.rust-lang.org/t/rust-for-embedded-development-where-we-are-and-whats-missing/10861\",\n        children: \"Rust for embedded-dev, where are we and what's missing\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Also, I don't know much about the current state of things in formal verification of the language; but would like to see activity/progress being made in that area too. There is one by \", _jsx(_components.a, {\n        href: \"https://people.mpi-sws.org/~dreyer/papers/rustbelt/paper.pdf\",\n        children: \"Ralf Jung\"\n      }), \". It is also desired that the language team progresses towards a standard specification of the language, similar to standards like ECMA standard and C++ ISO standard.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"on-async-io\",\n      children: _jsx(_components.a, {\n        href: \"#on-async-io\",\n        children: \"On Async I/O\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"I would also like to see \", _jsx(_components.a, {\n        href: \"https://github.com/alexcrichton/futures-await\",\n        children: \"async-await\"\n      }), \" sugars to be usable on stable Rust this year. Also a cookbook explaining future and tokio abstractions would be appreciated. I also feel that the \", _jsx(_components.code, {\n        children: \"futures\"\n      }), \" crate could be improved on error messages. Having worked with it, I feel the error messages are unreadable and sometimes diametric. For example:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"() {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\"\n        }), _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"ok_future\"\n        }), \" = ok::\u003c_,()\u003e(());\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\"\n        }), _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"composed\"\n        }), \" = ok_future.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"then\"\n        }), \"(|e| {\\n        ok::\u003c_,()\u003e(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \")\\n    });\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"mut \"\n        }), _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"core\"\n        }), \" = Core::\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"new\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"unwrap\"\n        }), \"();\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\"\n        }), _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"handle\"\n        }), \" = core.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"handle\"\n        }), \"();\\n    handle.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"spawn\"\n        }), \"(composed);\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"reports error as :\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"mismatch\"\n        }), \" resolving `\u003cfutures::Join\u003cfutures::Then\u003cfutures::FutureResult\u003c(), ()\u003e, futures::FutureResult\u003c\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"bool\"\n        }), \", ()\u003e, [closure@src/main.rs:\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"14\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"35\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"16\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \"]\u003e, futures::FutureResult\u003c\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"u32\"\n        }), \", ()\u003e\u003e \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" futures::Future\u003e::Item == ()`\\n  -\", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"-\u003e\"\n        }), \" src/main.rs:\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"21\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"12\"\n        }), \"\\n   |\\n\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"21\"\n        }), \" |     handle.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"spawn\"\n        }), \"(joined);\\n   |            ^^^^^ expected \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"bool\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"found\"\n        }), \" ()\\n   |\\n   = note: expected \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" `\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"bool\"\n        }), \"`\\n              found \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" `()`\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Ideally, the error message given by compiler should be the other way around i.e.,\\nIt should report:\\n\", _jsx(_components.code, {\n        children: \"the expected type is (), but found type is bool.\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It's easy to figure out the issue on your own in trivial cases like above, but becomes difficul to reason about when complex return types are involved. Also the verbose representation of composed futures type in \\\"\", _jsx(_components.code, {\n        children: \"type mismatch ...\"\n      }), \"\\\" statement above here can be shortened; I don't know, maybe by compiler plugins. For a new comer, these errors become overwhelming and gives an impression that the library is hard to work with. Also for returning futures we really need the \", _jsx(_components.a, {\n        href: \"https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md\",\n        children: \"impl trait RFC\"\n      }), \" to land on stable as most of the time we need to return boxes of futures which adds overhead.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"syntax-enhancements\",\n      children: _jsx(_components.a, {\n        href: \"#syntax-enhancements\",\n        children: \"Syntax enhancements:\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Small things\"\n      }), \":\\nSimilar to what we have for \", _jsx(_components.code, {\n        children: \"vec![]\"\n      }), \" provided by the \", _jsx(_components.a, {\n        href: \"https://doc.rust-lang.org/std/macro.vec.html\",\n        children: \"standard library\"\n      }), \", other container types can also benefit from shorthands  implemented as macros like \", _jsx(_components.code, {\n        children: \"map!{}\"\n      }), \", \", _jsx(_components.code, {\n        children: \"bmap!{}\"\n      }), \", \", _jsx(_components.code, {\n        children: \"set!{}\"\n      }), \". There are already macro \", _jsx(_components.a, {\n        href: \"https://docs.rs/maplit/1.0.2/maplit/\",\n        children: \"crates\"\n      }), \" for doing this but the standard library can already provide them just like it has for vec![]. The fact that these crates exist outside the offical ecosystem means that there's a use case for it. These are small things but can greatly improve coding experience.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Idea of data structs/classes\"\n      }), \" - This is taken from Kotlin's \", _jsx(_components.a, {\n        href: \"https://kotlinlang.org/docs/reference/data-classes.html\",\n        children: \"data classes\"\n      }), \", where you can prefix a class with \", _jsx(_components.code, {\n        children: \"data\"\n      }), \" keyword and your class automatically gets a default all parameter constructors and getters and setters too. In Rust, this can translate to a \", _jsx(_components.code, {\n        children: \"#[derive(new, getter, setter)]\"\n      }), \" or a \", _jsx(_components.code, {\n        children: \"#[derive(DataStruct)]\"\n      }), \" on top of struct or enum declarations. There are times we just want to have bunch of fields together in a struct and just access or set them later. This abstraction can become really handy in minimizing boilerplate code.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"String template literals\"\n      }), \": It becomes quite verbose to use \", _jsx(_components.code, {\n        children: \"format!(\\\"Foo{}\\\",\\\"Bar\\\")\"\n      }), \" everytime we want to use interpolated strings. Something like \", _jsx(_components.code, {\n        children: \"\\\\`Foo{bar}\\\\\"\n      }), \" will be awesome if possible. There have been discussion on \", _jsx(_components.a, {\n        href: \"https://mail.mozilla.org/pipermail/rust-dev/2012-February/001346.html\",\n        children: \"this\"\n      }), \" and also an issue \", _jsx(_components.a, {\n        href: \"https://github.com/rust-lang/rfcs/issues/1250\",\n        children: \"#1250\"\n      }), \". Also slice patterns like \", _jsx(_components.code, {\n        children: \"let \u0026[a,b,_,_,_] = \u0026[1,2,3,4,5]\"\n      }), \" should be stable.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Default argument methods\"\n      }), \" - Methods with default arguments eliminate the need to provide a seperate set method on structs. Relevant issue \", _jsx(_components.a, {\n        href: \"https://github.com/rust-lang/rfcs/issues/323\",\n        children: \"#323\"\n      }), \". There are many others and would possibly make this post long if I list here.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"on-tooling-and-infrastructure\",\n      children: _jsx(_components.a, {\n        href: \"#on-tooling-and-infrastructure\",\n        children: \"On tooling and infrastructure:\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"I want to talk about the cross compilation tooling. There is \", _jsx(_components.a, {\n        href: \"https://github.com/japaric/xargo\",\n        children: \"xargo\"\n      }), \" which makes it easy to pull source of Rust's standard library and helps to cross compile crates to other\\nplatforms. xargo's functionality just be integrated within cargo itself. This will make cargo more versatile tool on the cross compilation space.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"guides-for-intermediate-programmers\",\n      children: _jsx(_components.a, {\n        href: \"#guides-for-intermediate-programmers\",\n        children: \"Guides for intermediate programmers\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Last year the community made efforts for curating newbies to Rust. This year should be for intermediate rustaceans who want to upgrade their Rust skills. We want better examples/patterns/cookbook describing when lifetime annotations are really necessary in code. Guides on using the type systems well to encode semantics at compile time into the program. Tutorials on implementing non-trivial data structures and container types and how it compares to other languages. There is already a beautiful one by \", _jsx(_components.a, {\n        href: \"http://cglab.ca/~abeinges/blah/too-many-lists/book/\",\n        children: \"alexis\"\n      }), \" but we need more like that.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"tooling-for-benchmarking-profiling-rust-programs\",\n      children: _jsx(_components.a, {\n        href: \"#tooling-for-benchmarking-profiling-rust-programs\",\n        children: \"Tooling for Benchmarking, profiling Rust programs\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The profiling story also needs to improve this year. There have been good efforts to integrate existing tools within cargo such as \", _jsx(_components.a, {\n        href: \"https://github.com/kernelmachine/cargo-profiler\",\n        children: \"cargo-profiler\"\n      }), \" but they need to support Windows and macOS as well.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"more-macro-guides\",\n      children: _jsx(_components.a, {\n        href: \"#more-macro-guides\",\n        children: \"More macro guides\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Macros are really useful but the complex ones are harder to write for newbies. To encourage more people to use it, I would like to see a dedicated book for macros for coding idioms and best practices/gotchas for intermediate programmers. These days crates seem to be using macros heavily (looking at \", _jsx(_components.a, {\n        href: \"https://rocket.rs/\",\n        children: _jsx(_components.code, {\n          children: \"rocket\"\n        })\n      }), \") and someone attempting to understand and contribute to the macro code has to patiently read the cryptic patterns or even experiment the macro code in isolation to make sense of what it is actually doing. Blog post like Julia's \", _jsx(_components.a, {\n        href: \"https://jvns.ca/blog/2017/12/24/my-first-rust-macro/\",\n        children: \"post\"\n      }), \" are really appreciated.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"bringing-more-people-to-rust-compiler-hacking\",\n      children: _jsx(_components.a, {\n        href: \"#bringing-more-people-to-rust-compiler-hacking\",\n        children: \"Bringing more people to Rust compiler hacking\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This \", _jsx(_components.a, {\n        href: \"https://internals.rust-lang.org/t/so-you-want-to-hack-on-the-rust-compiler-a-plan-for-a-book/6497\",\n        children: \"post\"\n      }), \" really got me excited. With such efforts Rust community is making great strides in democratizing the knowledge of systems programming topics such as compilers, operating systems, garbage collectors, and other low level concepts to the masses which before, was only limited to a few wizards. A big shoutout to \", _jsx(_components.a, {\n        href: \"https://github.com/nikomatsakis\",\n        children: _jsx(_components.code, {\n          children: \"niko\"\n        })\n      }), \" and compiler team for progressing this in 2018.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Will close it here today, wish you all a happy new year! :)\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"meta":{"excerpt":"Towards a widely adopted language in all areas","slug":"rust-2018","title":"Making Rust more awesome in 2018 - My wishlist","tags":["community","new-goals","new-year"],"date":"Sat Jan 20 2018 05:30:00 GMT+0530 (India Standard Time)","author":"","readingTime":"6min"}}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"rust-2018"},"buildId":"C0oqtusQj9cY-EdwLN_RL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>