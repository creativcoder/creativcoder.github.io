<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>creativcoder</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/ab2a2959b9ba8661.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ab2a2959b9ba8661.css" data-n-g=""/><link rel="preload" href="/_next/static/css/f16eaa9e44b97d3f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f16eaa9e44b97d3f.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-9faa89de3ee6e754.js" defer=""></script><script src="/_next/static/chunks/framework-a87821de553db91d.js" defer=""></script><script src="/_next/static/chunks/main-32a43e1092778ede.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2e588ff4f55f23af.js" defer=""></script><script src="/_next/static/chunks/167-4ae4480dee839e87.js" defer=""></script><script src="/_next/static/chunks/675-f43734e7770ea31e.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-c606869ed04a3d0b.js" defer=""></script><script src="/_next/static/C0oqtusQj9cY-EdwLN_RL/_buildManifest.js" defer=""></script><script src="/_next/static/C0oqtusQj9cY-EdwLN_RL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="" style="position:fixed;top:0;left:0;height:3px;background:transparent;z-index:99999999999;width:100%"><div class="" style="height:100%;background:#4CE0B3;transition:all 500ms ease;width:0%"><div style="box-shadow:0 0 10px #4CE0B3, 0 0 10px #4CE0B3;width:5%;opacity:1;position:absolute;height:100%;transition:all 500ms ease;transform:rotate(3deg) translate(0px, -4px);left:-10rem"></div></div></div><div class="flex min-h-screen w-screen overflow-hidden flex-col items-center dark:bg-[#242729] bg-slate-200 backdrop" style="opacity:0.5;background-color:#E2E8F0"><div class="max-w-2xl md:max-w-3xl lg:max-w-4xl space-y-12 w-screen sticky"><nav class="bg-[#f6f8f9] dark:bg-[#2b2e30] dark:shadow-md m-3 rounded-lg shadow-sm backdrop-filter backdrop-blur-md bg-opacity-40 sticky top-0 mt-10"><div class="mx-auto p-4"><div class="flex justify-between"><div class="cursor-pointer flex space-x-2 items-center"><div><img src="/logo_v3.svg" width="26" class="pt-0.5 invert"/></div><div class="text-lg dark:text-white hidden md:block">creativcoder</div></div><div class="flex items-center pr-2"><ul class="hidden md:flex md:space-x-4 pr-3"><a class="hover:text-slate-500 dark:text-slate-200 text-slate-700 transition flex items-center" href="/blog"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M18.404 2.998c-.757-.754-2.077-.751-2.828.005l-1.784 1.791L11.586 7H7a.998.998 0 0 0-.939.658l-4 11c-.133.365-.042.774.232 1.049l2 2a.997.997 0 0 0 1.049.232l11-4A.998.998 0 0 0 17 17v-4.586l2.207-2.207v-.001h.001L21 8.409c.378-.378.586-.881.585-1.415 0-.535-.209-1.038-.588-1.415l-2.593-2.581zm-3.111 8.295A.996.996 0 0 0 15 12v4.3l-9.249 3.363 4.671-4.671c.026.001.052.008.078.008A1.5 1.5 0 1 0 9 13.5c0 .026.007.052.008.078l-4.671 4.671L7.7 9H12c.266 0 .52-.105.707-.293L14.5 6.914 17.086 9.5l-1.793 1.793zm3.206-3.208-2.586-2.586 1.079-1.084 2.593 2.581-1.086 1.089z"></path></svg></a><a class="hover:text-slate-500 dark:text-slate-200 text-slate-700 transition flex items-center" href="https://youtube.com/@creativcoder"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="24" width="24" xmlns="http://www.w3.org/2000/svg"><g><path fill="none" d="M0 0h24v24H0z"></path><path fill-rule="nonzero" d="M19.606 6.995c-.076-.298-.292-.523-.539-.592C18.63 6.28 16.5 6 12 6s-6.628.28-7.069.403c-.244.068-.46.293-.537.592C4.285 7.419 4 9.196 4 12s.285 4.58.394 5.006c.076.297.292.522.538.59C5.372 17.72 7.5 18 12 18s6.629-.28 7.069-.403c.244-.068.46-.293.537-.592C19.715 16.581 20 14.8 20 12s-.285-4.58-.394-5.005zm1.937-.497C22 8.28 22 12 22 12s0 3.72-.457 5.502c-.254.985-.997 1.76-1.938 2.022C17.896 20 12 20 12 20s-5.893 0-7.605-.476c-.945-.266-1.687-1.04-1.938-2.022C2 15.72 2 12 2 12s0-3.72.457-5.502c.254-.985.997-1.76 1.938-2.022C6.107 4 12 4 12 4s5.896 0 7.605.476c.945.266 1.687 1.04 1.938 2.022zM10 15.5v-7l6 3.5-6 3.5z"></path></g></svg></a><a class="hover:text-slate-500 dark:text-slate-200 text-slate-700 transition flex items-center" href="/about"><svg stroke="currentColor" fill="none" stroke-width="0" viewBox="0 0 24 24" height="24" width="24" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M16 9C16 11.2091 14.2091 13 12 13C9.79086 13 8 11.2091 8 9C8 6.79086 9.79086 5 12 5C14.2091 5 16 6.79086 16 9ZM14 9C14 10.1046 13.1046 11 12 11C10.8954 11 10 10.1046 10 9C10 7.89543 10.8954 7 12 7C13.1046 7 14 7.89543 14 9Z" fill="currentColor"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1ZM3 12C3 14.0902 3.71255 16.014 4.90798 17.5417C6.55245 15.3889 9.14627 14 12.0645 14C14.9448 14 17.5092 15.3531 19.1565 17.4583C20.313 15.9443 21 14.0524 21 12C21 7.02944 16.9706 3 12 3C7.02944 3 3 7.02944 3 12ZM12 21C9.84977 21 7.87565 20.2459 6.32767 18.9878C7.59352 17.1812 9.69106 16 12.0645 16C14.4084 16 16.4833 17.1521 17.7538 18.9209C16.1939 20.2191 14.1881 21 12 21Z" fill="currentColor"></path></svg></a></ul><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="md:hidden block"><path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path></svg></div></div></div></nav><div><article class="dark:text-slate-200 dark:prose-headings:text-slate-200 dark:prose-code:text-slate-200 dark:prose-blockquote:text-slate-200 dark:prose-strong:text-slate-100 dark:prose-pre:bg-zinc-900 dark:prose-pre:shadow-md dark:prose-pre:border-gray-600 dark:prose-pre:border-[1.4px] dark:prose-a:text-slate-200 prose prose-xl flex flex-col mx-auto max-w-6xl justify-center pl-6 pr-6 prose-p:m-3 prose-headings:mb-3 prose-headings:mt-3 prose-a:font-bold prose-img:rounded-lg prose-img:m-auto prose-img:w-full prose-img:shadow-lg prose-code:font-jetbrains prose-pre:p-0 prose-a:no-underline prose-h1:text-4xl prose-h1:pl-2 prose-h2:pl-2 prose-blockquote:border-slate-600 prose-h2:text-xl"><div class="flex flex-col"><p class="text-4xl font-bold">Merge k sorted arrays in Rust</p><div class="pt-3 flex justify-between flex-row-reverse"><div class="flex items-center space-x-2"><p class="text-sm">7th December 2020</p></div><div class="flex items-center space-x-2"><p class="text-sm tracking-wide">creativcoder<!-- --> / <!-- -->9min<!-- --></p></div></div><div class="flex justify-center"><hr class="mb-8 h-px bg-gray-400 border-0 dark:bg-gray-500 w-full"/></div></div><p><img src="https://dev-to-uploads.s3.amazonaws.com/i/aoh6yf5y0jv5q7kqad0e.png" alt="Cover"/></p>
<!-- --><p>The other day, I was reading about LSM Tree based database storage engines (specifically, the LevelDB <!-- --><a href="https://github.com/google/leveldb/blob/master/doc/impl.md">docs</a>) where I came to know about a phase called compaction. LSM Tree based database storage engines are key-value storage systems where every operation is append only to favour less <!-- --><a href="https://en.wikipedia.org/wiki/Write_amplification">write amplification</a> and to reduce latency. LevelDB persists data file segments to disk (when the in-memory table hits a threshold) in sorted order to support efficient read queries. Even operations such as deletes or updates appends new entries to the underlying storage and this often leads to keys that are obsolete but still remain on disk and that increases disk usage. To overcome this, they often use a phase called <!-- --><em>compaction</em> where several sorted files are merged into single file to remove old data records in background. In order to implement a similar compaction strategy in my toy database project, I used the <!-- --><code>merge</code> sub-routine from merge sort, generalizing it to k sorted arrays. In this post, I write about the implementation of the merge k algorithm in Rust. If you know the merge sub-routine from merge sort, you should feel right at home understanding the algorithm.<!-- --></p>
<!-- --><h1 id="the-problem"><a href="#the-problem">The problem</a></h1>
<!-- --><p>Before formalizing the solution, we&#x27;ll re-state the problem again with examples and reason up from there to come up with an implementation in Rust.</p>
<!-- --><p>We are given <!-- --><code>k</code> array of items that are sorted. The problem is to implement a function that given <!-- --><code>k</code> sorted arrays, merges them and returns an array where all the elements are in sorted order.<!-- --></p>
<!-- --><p>For example, If we are given 2 sorted arrays:</p>
<!-- --><p><code>a = [3, 5]</code></p>
<!-- --><p><code>b = [2, 7]</code> where <!-- --><code>k = 2</code></p>
<!-- --><p>Then the merged array we get, would be <!-- --><code>c = [2, 3, 5, 7]</code></p>
<!-- --><h1 id="obvious-naive-solution"><a href="#obvious-naive-solution">Obvious naive solution</a></h1>
<!-- --><p>It&#x27;s always a good idea to start with what you already know as the thinking lends itself to revealing more about the problem at hand. So, the obvious approach to solve this would be to just concatenate the two arrays and sort them. Here&#x27;s a solution in Rust:</p>
<!-- --><pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <!-- --><span class="hljs-title function_">main</span>() {
    <!-- --><span class="hljs-keyword">let</span> <!-- --><span class="hljs-keyword"></span><span class="hljs-variable">a</span> = <!-- --><span class="hljs-built_in">vec!</span>[<!-- --><span class="hljs-number">3</span>, <!-- --><span class="hljs-number">5</span>];
    <!-- --><span class="hljs-keyword">let</span> <!-- --><span class="hljs-keyword"></span><span class="hljs-variable">b</span> = <!-- --><span class="hljs-built_in">vec!</span>[<!-- --><span class="hljs-number">2</span>, <!-- --><span class="hljs-number">7</span>];
    <!-- --><span class="hljs-keyword">let</span> <!-- --><span class="hljs-keyword"></span><span class="hljs-variable">c</span> = [a, b].<!-- --><span class="hljs-title function_ invoke__">concat</span>();
    a.<!-- --><span class="hljs-title function_ invoke__">sort</span>();
    dbg!(a);
}
<!-- --></code></pre>
<!-- --><p>That was quite easy, but it does have a <!-- --><code>O(n*k * log n*k)</code> worst case time complexity, where <!-- --><code>n</code> is the size of the resulting vector and <!-- --><code>k</code> is the number of arrays. Can we do better?<!-- --></p>
<!-- --><p>Let&#x27;s try a different approach. Without thinking about the implementation, how would you normally put these elements in order by hand? Let&#x27;s distill down the above example and give it a thought with a case by case analysis.</p>
<!-- --><h4 id="case-1"><a href="#case-1">Case 1:</a></h4>
<!-- --><p>Let&#x27;s say for example, the arrays have only 1 element in them:</p>
<!-- --><pre><code class="hljs language-rust">a = [<!-- --><span class="hljs-number">3</span>]
b = [<!-- --><span class="hljs-number">2</span>]
<!-- --></code></pre>
<!-- --><p>In this case, it&#x27;s pretty trivial. We just compare the first item with the second and take the smallest of the two, and insert it as first element in the resulting array: <!-- --><code>[2]</code>. What remains is <!-- --><code>3</code> from <!-- --><code>a</code> which we then append giving us <!-- --><code>[2, 3]</code> as the merged sequence.<!-- --></p>
<!-- --><h4 id="case-2"><a href="#case-2">Case 2:</a></h4>
<!-- --><p>Now, let&#x27;s consider if one of the arrays have more than one element:</p>
<!-- --><pre><code class="hljs language-rust">a = [<!-- --><span class="hljs-number">3</span>]
b = [<!-- --><span class="hljs-number">2</span>, <!-- --><span class="hljs-number">5</span>]
<!-- --></code></pre>
<!-- --><p>In this case, we&#x27;ll start again with the first item in both arrays and pick the smallest of the two items which is <!-- --><code>2</code>. The next item to compare is <!-- --><code>3</code> (from <!-- --><code>a</code>) and <!-- --><code>5</code> (from <!-- --><code>b</code>), among which <!-- --><code>3</code> is chosen as the next smallest element. At this point in time, we have exhausted all items in array <!-- --><code>a</code>. Now, whatever remains to be put in the merged array has to be from array <!-- --><code>b</code>. This is because of the invariant that we always pick the smallest item in each iteration so if all items from array <!-- --><code>a</code> are exhausted, all remaining elements must be greater than last element in <!-- --><code>a</code>. So we append <!-- --><code>5</code> from <!-- --><code>b</code> to our merged array to give us: <!-- --><code>[2, 3, 5]</code>.<!-- --></p>
<!-- --><p>From the dry run of the above two cases, you must have already thought of using two variables as indexes over the arrays and walk over them one by one, taking the next smallest element in each iteration until one of them exhausts, and then copy all the items from the remaining array to our merged sequence. Sounds simple? Let&#x27;s implement that:</p>
<!-- --><h2 id="implementation-of-merge-k-where-k--2"><a href="#implementation-of-merge-k-where-k--2">Implementation of merge k, where k = 2</a></h2>
<!-- --><p>To simplify the implementation for readability, we&#x27;ll limit the items to integer (<!-- --><code>i32</code>) values. Once we have the implementation in place, one can refactor it easily to make it generic over any <!-- --><code>T</code>.<!-- --></p>
<!-- --><p>Here&#x27;s how we can implement the above index pointer based solution in Rust:</p>
<!-- --><pre><code class="hljs language-rust">
<!-- --><span class="hljs-keyword">fn</span> <!-- --><span class="hljs-title function_">merge</span>(a: &amp;[<!-- --><span class="hljs-type">i32</span>], b: &amp;[<!-- --><span class="hljs-type">i32</span>]) <!-- --><span class="hljs-punctuation">-&gt;</span> <!-- --><span class="hljs-type">Vec</span>&lt;<!-- --><span class="hljs-type">i32</span>&gt; {
    <!-- --><span class="hljs-keyword">let</span> (<!-- --><span class="hljs-keyword">mut</span> i, <!-- --><span class="hljs-keyword">mut</span> j) = (<!-- --><span class="hljs-number">0</span>, <!-- --><span class="hljs-number">0</span>);
    <!-- --><span class="hljs-keyword">let</span> <!-- --><span class="hljs-keyword">mut </span><span class="hljs-variable">sorted</span> = <!-- --><span class="hljs-built_in">vec!</span>[];
    <!-- --><span class="hljs-keyword">let</span> <!-- --><span class="hljs-keyword"></span><span class="hljs-variable">remaining</span>;
    <!-- --><span class="hljs-keyword">let</span> <!-- --><span class="hljs-keyword"></span><span class="hljs-variable">remaining_idx</span>;
    <!-- --><span class="hljs-keyword">loop</span> {
        <!-- --><span class="hljs-keyword">if</span> a[i] &lt; b[j] {
            sorted.<!-- --><span class="hljs-title function_ invoke__">push</span>(a[i]);
            i += <!-- --><span class="hljs-number">1</span>;
            <!-- --><span class="hljs-keyword">if</span> i == a.<!-- --><span class="hljs-title function_ invoke__">len</span>() {remaining = b; remaining_idx = j; <!-- --><span class="hljs-keyword">break</span>;}
        } <!-- --><span class="hljs-keyword">else</span> {
            sorted.<!-- --><span class="hljs-title function_ invoke__">push</span>(b[j]);
            j += <!-- --><span class="hljs-number">1</span>;
            <!-- --><span class="hljs-keyword">if</span> j == b.<!-- --><span class="hljs-title function_ invoke__">len</span>() {remaining = a; remaining_idx = i; <!-- --><span class="hljs-keyword">break</span>;}
        }
    }
    <!-- --><span class="hljs-keyword">for</span> <!-- --><span class="hljs-variable">i</span> <!-- --><span class="hljs-keyword">in</span> remaining_idx..remaining.<!-- --><span class="hljs-title function_ invoke__">len</span>() {
        sorted.<!-- --><span class="hljs-title function_ invoke__">push</span>(remaining[i]);
    }
    
    sorted
}
<!-- --></code></pre>
<!-- --><p>We have the <!-- --><code>merge</code> function defined that takes in two slices of integers aka reference to an array of integers and returns a <!-- --><code>Vec&lt;i32&gt;</code> (a heap allocated value). Within <!-- --><code>merge</code>, we create two indexes <!-- --><code>i, j</code> that start with <!-- --><code>0</code>. We also create a <!-- --><code>remaining</code> and <!-- --><code>remaining_idx</code> to point to the array that gets left after all items from the other array gets exhausted. Next, we run a <!-- --><code>loop {}</code>, where we pick the smallest item, push it to <!-- --><code>sorted</code> and increment the respective index. We also do an additional check if we reach the end on one of the arrays and assign <!-- --><code>remaining</code> and <!-- --><code>remaining_idx</code> accordingly. After the loop, we loop over the <!-- --><code>remaining</code> array items and push to <!-- --><code>sorted</code>.<!-- --></p>
<!-- --><p>But, the above solution works only for 2 arrays. We need to generalize the solution to k sorted arrays.</p>
<!-- --><h2 id="generalizing-to-k-sorted-arrays"><a href="#generalizing-to-k-sorted-arrays">Generalizing to k sorted arrays</a></h2>
<!-- --><p>How would one extend the above solution to k sorted collection of items?</p>
<!-- --><p>Well it turns out that now we need to keep k pointers to k arrays and pick the smallest item out of k. It&#x27;s easy enough to write code to keep track of the pointers, if we have let&#x27;s say &lt; 10 or &lt; 100 arrays to be merged. Or instead of keeping pointers, we could store an array of indexes into the arrays. That&#x27;s another solution that works again for smaller values of k. But, it&#x27;s not a convenient or maintainable code to write when we have very large arrays to be merged. Moreover, the number of comparision increases linearly as k increases.</p>
<!-- --><p>Following along the same solution, let&#x27;s think about what we need to find from the k arrays at the first iteration of the loop. That&#x27;s right, we need to find the minimum from k items. This might give you a hint of using some data structure that supports getting minimum item from the <!-- --><code>k</code> items. One data structure that comes to my mind is the heap data structure. In particular, a min-heap data structure.<!-- --></p>
<!-- --><h2 id="enter-the-min-heap"><a href="#enter-the-min-heap">Enter the min heap</a></h2>
<!-- --><p>A Heap is a complete binary tree (nodes are inserted breadth first left to right) where there&#x27;s a relation between parent and child nodes. This is the heap property. There are two variants of heap: min heap and max heap. In min heap the every parent node is smaller than the child and conversely for the max heap. At minimum, any implementation supports three key APIs:</p>
<!-- --><ol>
<!-- --><li>inserting - Adds an element to the heap</li>
<!-- --><li>removing - Removes an element to the heap</li>
<!-- --><li>heapify - rebalances the tree while maintaining the heap property.</li>
<!-- --></ol>
<!-- --><p>At all times the heap property must be maintained when inserting or removing items from the heap. Internally the heap uses the <!-- --><code>siftDown</code> and <!-- --><code>bubbleUp</code> sub-routines to maintain the heap property.<!-- --></p>
<!-- --><p>So using a min-heap, we can insert the first k items into the array. Then we keep popping until our heap is empty and keeping the array indexes.</p>
<!-- --><p>To implement this, we need to modify our solution a bit.</p>
<!-- --><p>Our <!-- --><code>merge</code> method now takes in a <!-- --><code>Vec&lt;Vec&lt;i32&gt;&gt;</code> as a parameter (an array of array of signed integers):<!-- --></p>
<!-- --><pre><code class="hljs language-rust">
<!-- --><span class="hljs-keyword">fn</span> <!-- --><span class="hljs-title function_">merge</span>(arrays: <!-- --><span class="hljs-type">Vec</span>&lt;<!-- --><span class="hljs-type">Vec</span>&lt;<!-- --><span class="hljs-type">i32</span>&gt;&gt;) {

}

<!-- --></code></pre>
<!-- --><p>Next, let&#x27;s create an <!-- --><code>Item</code> struct that will hold references to the k arrays and their respective index as their iteration state. The index will tell us where in our array we are currently at. This <!-- --><code>Item</code> instance will be the element that goes in our min heap.<!-- --></p>
<!-- --><pre><code class="hljs language-rust"><span class="hljs-meta">#[derive(Debug, Eq)]</span>
<!-- --><span class="hljs-keyword">struct</span> <!-- --><span class="hljs-title class_">Item</span>&lt;<!-- --><span class="hljs-symbol">&#x27;a</span>&gt; {
    arr: &amp;<!-- --><span class="hljs-symbol">&#x27;a</span> <!-- --><span class="hljs-type">Vec</span>&lt;<!-- --><span class="hljs-type">i32</span>&gt;,
    idx: <!-- --><span class="hljs-type">usize</span>
}
<!-- --></code></pre>
<!-- --><p>Now <!-- --><code>Item</code> doesn&#x27;t convey how they should be compared, as it&#x27;s a new data type we&#x27;ve defined. So we need to tell the type system how they should be compared. Doing this is easy and we&#x27;ll just need to implement a few traits and defer the comparision to the elements of the array using a helper method <!-- --><code>get_item</code> (we define). On the <!-- --><code>Item</code> struct we&#x27;ll implement the required traits (<!-- --><code>PartialEq</code>, <!-- --><code>PartialOrd</code>, <!-- --><code>Ord</code>) so that it can be inserted into min-heap:<!-- --></p>
<!-- --><pre><code class="hljs language-rust">
<!-- --><span class="hljs-keyword">impl</span>&lt;<!-- --><span class="hljs-symbol">&#x27;a</span>&gt; <!-- --><span class="hljs-built_in">PartialEq</span> <!-- --><span class="hljs-keyword">for</span> <!-- --><span class="hljs-title class_">Item</span>&lt;<!-- --><span class="hljs-symbol">&#x27;a</span>&gt; {
    <!-- --><span class="hljs-keyword">fn</span> <!-- --><span class="hljs-title function_">eq</span>(&amp;<!-- --><span class="hljs-keyword">self</span>, other: &amp;<!-- --><span class="hljs-keyword">Self</span>) <!-- --><span class="hljs-punctuation">-&gt;</span> <!-- --><span class="hljs-type">bool</span> {
        <!-- --><span class="hljs-keyword">self</span>.<!-- --><span class="hljs-title function_ invoke__">get_item</span>() == other.<!-- --><span class="hljs-title function_ invoke__">get_item</span>()
    }
}

<!-- --><span class="hljs-keyword">impl</span>&lt;<!-- --><span class="hljs-symbol">&#x27;a</span>&gt; <!-- --><span class="hljs-built_in">PartialOrd</span> <!-- --><span class="hljs-keyword">for</span> <!-- --><span class="hljs-title class_">Item</span>&lt;<!-- --><span class="hljs-symbol">&#x27;a</span>&gt; {
    <!-- --><span class="hljs-keyword">fn</span> <!-- --><span class="hljs-title function_">partial_cmp</span>(&amp;<!-- --><span class="hljs-keyword">self</span>, other: &amp;<!-- --><span class="hljs-keyword">Self</span>) <!-- --><span class="hljs-punctuation">-&gt;</span> <!-- --><span class="hljs-type">Option</span>&lt;Ordering&gt; {
        <!-- --><span class="hljs-keyword">self</span>.<!-- --><span class="hljs-title function_ invoke__">get_item</span>().<!-- --><span class="hljs-title function_ invoke__">partial_cmp</span>(&amp;other.<!-- --><span class="hljs-title function_ invoke__">get_item</span>())
    }
}

<!-- --><span class="hljs-keyword">impl</span>&lt;<!-- --><span class="hljs-symbol">&#x27;a</span>&gt; <!-- --><span class="hljs-built_in">Ord</span> <!-- --><span class="hljs-keyword">for</span> <!-- --><span class="hljs-title class_">Item</span>&lt;<!-- --><span class="hljs-symbol">&#x27;a</span>&gt; {
    <!-- --><span class="hljs-keyword">fn</span> <!-- --><span class="hljs-title function_">cmp</span>(&amp;<!-- --><span class="hljs-keyword">self</span>, other: &amp;<!-- --><span class="hljs-keyword">Self</span>) <!-- --><span class="hljs-punctuation">-&gt;</span> Ordering {
        <!-- --><span class="hljs-keyword">self</span>.<!-- --><span class="hljs-title function_ invoke__">get_item</span>().<!-- --><span class="hljs-title function_ invoke__">cmp</span>(&amp;other.<!-- --><span class="hljs-title function_ invoke__">get_item</span>())
    }    
}
<!-- --></code></pre>
<!-- --><p>We also have a few helper methods <!-- --><code>new</code> and <!-- --><code>get_item</code> purely for convenience.<!-- --></p>
<!-- --><pre><code class="hljs language-rust"><span class="hljs-keyword">impl</span>&lt;<!-- --><span class="hljs-symbol">&#x27;a</span>&gt; Item&lt;<!-- --><span class="hljs-symbol">&#x27;a</span>&gt; {
    <!-- --><span class="hljs-keyword">fn</span> <!-- --><span class="hljs-title function_">new</span>(arr: &amp;<!-- --><span class="hljs-symbol">&#x27;a</span> <!-- --><span class="hljs-type">Vec</span>&lt;<!-- --><span class="hljs-type">i32</span>&gt;, idx: <!-- --><span class="hljs-type">usize</span>) <!-- --><span class="hljs-punctuation">-&gt;</span> <!-- --><span class="hljs-keyword">Self</span> {
        <!-- --><span class="hljs-keyword">Self</span> {
            arr,
            idx
        }
    }

    <!-- --><span class="hljs-keyword">fn</span> <!-- --><span class="hljs-title function_">get_item</span>(&amp;<!-- --><span class="hljs-keyword">self</span>) <!-- --><span class="hljs-punctuation">-&gt;</span> <!-- --><span class="hljs-type">i32</span> {
        <!-- --><span class="hljs-keyword">self</span>.arr[<!-- --><span class="hljs-keyword">self</span>.idx]
    }
}
<!-- --></code></pre>
<!-- --><p>Once we have the required traits implemented for <!-- --><code>Item</code>, we&#x27;ll then implement the new <!-- --><code>merge</code> algorithm:<!-- --></p>
<!-- --><pre><code class="hljs language-rust"><span class="hljs-keyword">use</span> std::collections::BinaryHeap;
<!-- --><span class="hljs-keyword">use</span> std::cmp::Reverse;
<!-- --><span class="hljs-keyword">use</span> std::cmp::Ordering;

<!-- --><span class="hljs-keyword">fn</span> <!-- --><span class="hljs-title function_">merge</span>(arrays: <!-- --><span class="hljs-type">Vec</span>&lt;<!-- --><span class="hljs-type">Vec</span>&lt;<!-- --><span class="hljs-type">i32</span>&gt;&gt;) <!-- --><span class="hljs-punctuation">-&gt;</span> <!-- --><span class="hljs-type">Vec</span>&lt;<!-- --><span class="hljs-type">i32</span>&gt; {
    <!-- --><span class="hljs-keyword">let</span> <!-- --><span class="hljs-keyword">mut </span><span class="hljs-variable">sorted</span> = <!-- --><span class="hljs-built_in">vec!</span>[];

    <!-- --><span class="hljs-keyword">let</span> <!-- --><span class="hljs-keyword">mut </span><span class="hljs-variable">heap</span> = BinaryHeap::<!-- --><span class="hljs-title function_ invoke__">with_capacity</span>(arrays.<!-- --><span class="hljs-title function_ invoke__">len</span>());
    <!-- --><span class="hljs-keyword">for</span> <!-- --><span class="hljs-variable">arr</span> <!-- --><span class="hljs-keyword">in</span> &amp;arrays {
        <!-- --><span class="hljs-keyword">let</span> <!-- --><span class="hljs-keyword"></span><span class="hljs-variable">item</span> = Item::<!-- --><span class="hljs-title function_ invoke__">new</span>(arr, <!-- --><span class="hljs-number">0</span>);
        heap.<!-- --><span class="hljs-title function_ invoke__">push</span>(<!-- --><span class="hljs-title function_ invoke__">Reverse</span>(item));
    }

    <!-- --><span class="hljs-keyword">while</span> !heap.<!-- --><span class="hljs-title function_ invoke__">is_empty</span>() {
        <!-- --><span class="hljs-keyword">let</span> <!-- --><span class="hljs-keyword">mut </span><span class="hljs-variable">it</span> = heap.<!-- --><span class="hljs-title function_ invoke__">pop</span>().<!-- --><span class="hljs-title function_ invoke__">unwrap</span>();
        sorted.<!-- --><span class="hljs-title function_ invoke__">push</span>(it.<!-- --><span class="hljs-number">0</span>.<!-- --><span class="hljs-title function_ invoke__">get_item</span>());
        it.<!-- --><span class="hljs-number">0</span>.idx += <!-- --><span class="hljs-number">1</span>;
        <!-- --><span class="hljs-keyword">if</span> it.<!-- --><span class="hljs-number">0</span>.idx &lt; it.<!-- --><span class="hljs-number">0</span>.arr.<!-- --><span class="hljs-title function_ invoke__">len</span>() {
            heap.<!-- --><span class="hljs-title function_ invoke__">push</span>(it)
        }
    }

    sorted
}
<!-- --></code></pre>
<!-- --><p>We create a <!-- --><code>Vec</code> that will hold our merged items. We then create a <!-- --><code>BinaryHeap</code> instance and push all items in <!-- --><code>arrays</code> as an <!-- --><code>Item</code> with the start index <!-- --><code>0</code>. We then wrap <!-- --><code>item</code> with <!-- --><code>Reverse</code> (as it&#x27;s a max heap by default) and push it to heap.<!-- --></p>
<!-- --><p>Next, we run a loop while we still have elements in heap. Within the loop, we get the smallest item by <!-- --><code>heap.pop()</code> and push it to <!-- --><code>sorted</code> and increment the item&#x27;s index by 1. Because we might still have items in the heap, we check for that and push it back in the last line.<!-- --></p>
<!-- --><p>Finally once we are done, we return the <!-- --><code>sorted</code> array.<!-- --></p>
<!-- --><p>For this solution our complexity now reduces to `O(n*k * Log(k))</p>
<!-- --><p>Finally let&#x27;s test this out on a sample dataset:</p>
<!-- --><pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <!-- --><span class="hljs-title function_">main</span>() {
    <!-- --><span class="hljs-keyword">let</span> <!-- --><span class="hljs-keyword"></span><span class="hljs-variable">a</span> = <!-- --><span class="hljs-built_in">vec!</span>[<!-- --><span class="hljs-number">1</span>, <!-- --><span class="hljs-number">5</span>, <!-- --><span class="hljs-number">7</span>];
    <!-- --><span class="hljs-keyword">let</span> <!-- --><span class="hljs-keyword"></span><span class="hljs-variable">b</span> = <!-- --><span class="hljs-built_in">vec!</span>[-<!-- --><span class="hljs-number">2</span>, <!-- --><span class="hljs-number">3</span>, <!-- --><span class="hljs-number">4</span>];
    <!-- --><span class="hljs-keyword">let</span> <!-- --><span class="hljs-keyword"></span><span class="hljs-variable">v</span> = <!-- --><span class="hljs-built_in">vec!</span>[a, b];
    dbg!(<!-- --><span class="hljs-title function_ invoke__">merge</span>(v));
}

<!-- --></code></pre>
<!-- --><p>Final code: https://gist.github.com/creativcoder/20fda0f1a947bf2af3b93ab394d6bacb</p>
<!-- --><h2 id="taking-it-a-step-further"><a href="#taking-it-a-step-further">Taking it a step further</a></h2>
<!-- --><p>An optimization on top of this would be to stream sorted values as they are processed by exposing an iterator over the <!-- --><code>k</code> items in heap.<!-- --></p>
<!-- --><p>With that said, I am open to suggestions, improvements to the solution and you can do so with comments below. Until next time!</p><div class="flex justify-center"><hr class="mb-8 h-px bg-gray-400 border-0 dark:bg-gray-500 w-full"/></div><p class="text-sm font-bold">Want to share feedback, or discuss further ideas? Feel free to leave a comment here! Please follow Rust&#x27;s code of conduct. This comment thread directly maps to a discussion on GitHub, so you can also comment there if you prefer.</p></article>;<!-- --></div><footer class="flex flex-col items-center w-full"><div class="px-4 py-2 flex items-center justify-center space-x-2 border-2 rounded-md border-gray-500 hover:bg-blue-100 transition-colors hover:text-lime-900"><svg stroke="currentColor" fill="currentColor" stroke-width="0" role="img" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><title></title><path d="M17.625 1.499c-2.32 0-4.354 1.203-5.625 3.03-1.271-1.827-3.305-3.03-5.625-3.03C3.129 1.499 0 4.253 0 8.249c0 4.275 3.068 7.847 5.828 10.227a33.14 33.14 0 0 0 5.616 3.876l.028.017.008.003-.001.003c.163.085.342.126.521.125.179.001.358-.041.521-.125l-.001-.003.008-.003.028-.017a33.14 33.14 0 0 0 5.616-3.876C20.932 16.096 24 12.524 24 8.249c0-3.996-3.129-6.75-6.375-6.75zm-.919 15.275a30.766 30.766 0 0 1-4.703 3.316l-.004-.002-.004.002a30.955 30.955 0 0 1-4.703-3.316c-2.677-2.307-5.047-5.298-5.047-8.523 0-2.754 2.121-4.5 4.125-4.5 2.06 0 3.914 1.479 4.544 3.684.143.495.596.797 1.086.796.49.001.943-.302 1.085-.796.63-2.205 2.484-3.684 4.544-3.684 2.004 0 4.125 1.746 4.125 4.5 0 3.225-2.37 6.216-5.048 8.523z"></path></svg><p>Be a GitHub Sponser</p></div><div class="flex-col items-center justify-center mt-8 mb-8"><div class="text-center text-xs mx-auto">© 2016-<!-- -->2022<!-- --> creativcoder. All rights reserved.<!-- --></div></div></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    a: \"a\",\n    em: \"em\",\n    code: \"code\",\n    h1: \"h1\",\n    pre: \"pre\",\n    span: \"span\",\n    h4: \"h4\",\n    h2: \"h2\",\n    ol: \"ol\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://dev-to-uploads.s3.amazonaws.com/i/aoh6yf5y0jv5q7kqad0e.png\",\n        alt: \"Cover\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The other day, I was reading about LSM Tree based database storage engines (specifically, the LevelDB \", _jsx(_components.a, {\n        href: \"https://github.com/google/leveldb/blob/master/doc/impl.md\",\n        children: \"docs\"\n      }), \") where I came to know about a phase called compaction. LSM Tree based database storage engines are key-value storage systems where every operation is append only to favour less \", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/Write_amplification\",\n        children: \"write amplification\"\n      }), \" and to reduce latency. LevelDB persists data file segments to disk (when the in-memory table hits a threshold) in sorted order to support efficient read queries. Even operations such as deletes or updates appends new entries to the underlying storage and this often leads to keys that are obsolete but still remain on disk and that increases disk usage. To overcome this, they often use a phase called \", _jsx(_components.em, {\n        children: \"compaction\"\n      }), \" where several sorted files are merged into single file to remove old data records in background. In order to implement a similar compaction strategy in my toy database project, I used the \", _jsx(_components.code, {\n        children: \"merge\"\n      }), \" sub-routine from merge sort, generalizing it to k sorted arrays. In this post, I write about the implementation of the merge k algorithm in Rust. If you know the merge sub-routine from merge sort, you should feel right at home understanding the algorithm.\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      id: \"the-problem\",\n      children: _jsx(_components.a, {\n        href: \"#the-problem\",\n        children: \"The problem\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Before formalizing the solution, we'll re-state the problem again with examples and reason up from there to come up with an implementation in Rust.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We are given \", _jsx(_components.code, {\n        children: \"k\"\n      }), \" array of items that are sorted. The problem is to implement a function that given \", _jsx(_components.code, {\n        children: \"k\"\n      }), \" sorted arrays, merges them and returns an array where all the elements are in sorted order.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For example, If we are given 2 sorted arrays:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"a = [3, 5]\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"b = [2, 7]\"\n      }), \" where \", _jsx(_components.code, {\n        children: \"k = 2\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Then the merged array we get, would be \", _jsx(_components.code, {\n        children: \"c = [2, 3, 5, 7]\"\n      })]\n    }), \"\\n\", _jsx(_components.h1, {\n      id: \"obvious-naive-solution\",\n      children: _jsx(_components.a, {\n        href: \"#obvious-naive-solution\",\n        children: \"Obvious naive solution\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It's always a good idea to start with what you already know as the thinking lends itself to revealing more about the problem at hand. So, the obvious approach to solve this would be to just concatenate the two arrays and sort them. Here's a solution in Rust:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"() {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\"\n        }), _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"a\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"vec!\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \"];\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\"\n        }), _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"b\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"vec!\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"7\"\n        }), \"];\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\"\n        }), _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"c\"\n        }), \" = [a, b].\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"concat\"\n        }), \"();\\n    a.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"sort\"\n        }), \"();\\n    dbg!(a);\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"That was quite easy, but it does have a \", _jsx(_components.code, {\n        children: \"O(n*k * log n*k)\"\n      }), \" worst case time complexity, where \", _jsx(_components.code, {\n        children: \"n\"\n      }), \" is the size of the resulting vector and \", _jsx(_components.code, {\n        children: \"k\"\n      }), \" is the number of arrays. Can we do better?\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's try a different approach. Without thinking about the implementation, how would you normally put these elements in order by hand? Let's distill down the above example and give it a thought with a case by case analysis.\"\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"case-1\",\n      children: _jsx(_components.a, {\n        href: \"#case-1\",\n        children: \"Case 1:\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's say for example, the arrays have only 1 element in them:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [\"a = [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \"]\\nb = [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \"]\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In this case, it's pretty trivial. We just compare the first item with the second and take the smallest of the two, and insert it as first element in the resulting array: \", _jsx(_components.code, {\n        children: \"[2]\"\n      }), \". What remains is \", _jsx(_components.code, {\n        children: \"3\"\n      }), \" from \", _jsx(_components.code, {\n        children: \"a\"\n      }), \" which we then append giving us \", _jsx(_components.code, {\n        children: \"[2, 3]\"\n      }), \" as the merged sequence.\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"case-2\",\n      children: _jsx(_components.a, {\n        href: \"#case-2\",\n        children: \"Case 2:\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now, let's consider if one of the arrays have more than one element:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [\"a = [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \"]\\nb = [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \"]\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In this case, we'll start again with the first item in both arrays and pick the smallest of the two items which is \", _jsx(_components.code, {\n        children: \"2\"\n      }), \". The next item to compare is \", _jsx(_components.code, {\n        children: \"3\"\n      }), \" (from \", _jsx(_components.code, {\n        children: \"a\"\n      }), \") and \", _jsx(_components.code, {\n        children: \"5\"\n      }), \" (from \", _jsx(_components.code, {\n        children: \"b\"\n      }), \"), among which \", _jsx(_components.code, {\n        children: \"3\"\n      }), \" is chosen as the next smallest element. At this point in time, we have exhausted all items in array \", _jsx(_components.code, {\n        children: \"a\"\n      }), \". Now, whatever remains to be put in the merged array has to be from array \", _jsx(_components.code, {\n        children: \"b\"\n      }), \". This is because of the invariant that we always pick the smallest item in each iteration so if all items from array \", _jsx(_components.code, {\n        children: \"a\"\n      }), \" are exhausted, all remaining elements must be greater than last element in \", _jsx(_components.code, {\n        children: \"a\"\n      }), \". So we append \", _jsx(_components.code, {\n        children: \"5\"\n      }), \" from \", _jsx(_components.code, {\n        children: \"b\"\n      }), \" to our merged array to give us: \", _jsx(_components.code, {\n        children: \"[2, 3, 5]\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"From the dry run of the above two cases, you must have already thought of using two variables as indexes over the arrays and walk over them one by one, taking the next smallest element in each iteration until one of them exhausts, and then copy all the items from the remaining array to our merged sequence. Sounds simple? Let's implement that:\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"implementation-of-merge-k-where-k--2\",\n      children: _jsx(_components.a, {\n        href: \"#implementation-of-merge-k-where-k--2\",\n        children: \"Implementation of merge k, where k = 2\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To simplify the implementation for readability, we'll limit the items to integer (\", _jsx(_components.code, {\n        children: \"i32\"\n      }), \") values. Once we have the implementation in place, one can refactor it easily to make it generic over any \", _jsx(_components.code, {\n        children: \"T\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here's how we can implement the above index pointer based solution in Rust:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [\"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"merge\"\n        }), \"(a: \u0026[\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"i32\"\n        }), \"], b: \u0026[\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"i32\"\n        }), \"]) \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"-\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Vec\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"i32\"\n        }), \"\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"mut\"\n        }), \" i, \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"mut\"\n        }), \" j) = (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"mut \"\n        }), _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"sorted\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"vec!\"\n        }), \"[];\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\"\n        }), _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"remaining\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\"\n        }), _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"remaining_idx\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"loop\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" a[i] \u003c b[j] {\\n            sorted.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"push\"\n        }), \"(a[i]);\\n            i += \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" i == a.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"len\"\n        }), \"() {remaining = b; remaining_idx = j; \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"break\"\n        }), \";}\\n        } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n            sorted.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"push\"\n        }), \"(b[j]);\\n            j += \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" j == b.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"len\"\n        }), \"() {remaining = a; remaining_idx = i; \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"break\"\n        }), \";}\\n        }\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"i\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" remaining_idx..remaining.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"len\"\n        }), \"() {\\n        sorted.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"push\"\n        }), \"(remaining[i]);\\n    }\\n    \\n    sorted\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We have the \", _jsx(_components.code, {\n        children: \"merge\"\n      }), \" function defined that takes in two slices of integers aka reference to an array of integers and returns a \", _jsx(_components.code, {\n        children: \"Vec\u003ci32\u003e\"\n      }), \" (a heap allocated value). Within \", _jsx(_components.code, {\n        children: \"merge\"\n      }), \", we create two indexes \", _jsx(_components.code, {\n        children: \"i, j\"\n      }), \" that start with \", _jsx(_components.code, {\n        children: \"0\"\n      }), \". We also create a \", _jsx(_components.code, {\n        children: \"remaining\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"remaining_idx\"\n      }), \" to point to the array that gets left after all items from the other array gets exhausted. Next, we run a \", _jsx(_components.code, {\n        children: \"loop {}\"\n      }), \", where we pick the smallest item, push it to \", _jsx(_components.code, {\n        children: \"sorted\"\n      }), \" and increment the respective index. We also do an additional check if we reach the end on one of the arrays and assign \", _jsx(_components.code, {\n        children: \"remaining\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"remaining_idx\"\n      }), \" accordingly. After the loop, we loop over the \", _jsx(_components.code, {\n        children: \"remaining\"\n      }), \" array items and push to \", _jsx(_components.code, {\n        children: \"sorted\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But, the above solution works only for 2 arrays. We need to generalize the solution to k sorted arrays.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"generalizing-to-k-sorted-arrays\",\n      children: _jsx(_components.a, {\n        href: \"#generalizing-to-k-sorted-arrays\",\n        children: \"Generalizing to k sorted arrays\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"How would one extend the above solution to k sorted collection of items?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Well it turns out that now we need to keep k pointers to k arrays and pick the smallest item out of k. It's easy enough to write code to keep track of the pointers, if we have let's say \u003c 10 or \u003c 100 arrays to be merged. Or instead of keeping pointers, we could store an array of indexes into the arrays. That's another solution that works again for smaller values of k. But, it's not a convenient or maintainable code to write when we have very large arrays to be merged. Moreover, the number of comparision increases linearly as k increases.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Following along the same solution, let's think about what we need to find from the k arrays at the first iteration of the loop. That's right, we need to find the minimum from k items. This might give you a hint of using some data structure that supports getting minimum item from the \", _jsx(_components.code, {\n        children: \"k\"\n      }), \" items. One data structure that comes to my mind is the heap data structure. In particular, a min-heap data structure.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"enter-the-min-heap\",\n      children: _jsx(_components.a, {\n        href: \"#enter-the-min-heap\",\n        children: \"Enter the min heap\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"A Heap is a complete binary tree (nodes are inserted breadth first left to right) where there's a relation between parent and child nodes. This is the heap property. There are two variants of heap: min heap and max heap. In min heap the every parent node is smaller than the child and conversely for the max heap. At minimum, any implementation supports three key APIs:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"inserting - Adds an element to the heap\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"removing - Removes an element to the heap\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"heapify - rebalances the tree while maintaining the heap property.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"At all times the heap property must be maintained when inserting or removing items from the heap. Internally the heap uses the \", _jsx(_components.code, {\n        children: \"siftDown\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"bubbleUp\"\n      }), \" sub-routines to maintain the heap property.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So using a min-heap, we can insert the first k items into the array. Then we keep popping until our heap is empty and keeping the array indexes.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To implement this, we need to modify our solution a bit.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Our \", _jsx(_components.code, {\n        children: \"merge\"\n      }), \" method now takes in a \", _jsx(_components.code, {\n        children: \"Vec\u003cVec\u003ci32\u003e\u003e\"\n      }), \" as a parameter (an array of array of signed integers):\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [\"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"merge\"\n        }), \"(arrays: \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Vec\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Vec\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"i32\"\n        }), \"\u003e\u003e) {\\n\\n}\\n\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Next, let's create an \", _jsx(_components.code, {\n        children: \"Item\"\n      }), \" struct that will hold references to the k arrays and their respective index as their iteration state. The index will tell us where in our array we are currently at. This \", _jsx(_components.code, {\n        children: \"Item\"\n      }), \" instance will be the element that goes in our min heap.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"#[derive(Debug, Eq)]\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"struct\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Item\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \"'a\"\n        }), \"\u003e {\\n    arr: \u0026\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \"'a\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Vec\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"i32\"\n        }), \"\u003e,\\n    idx: \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"usize\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now \", _jsx(_components.code, {\n        children: \"Item\"\n      }), \" doesn't convey how they should be compared, as it's a new data type we've defined. So we need to tell the type system how they should be compared. Doing this is easy and we'll just need to implement a few traits and defer the comparision to the elements of the array using a helper method \", _jsx(_components.code, {\n        children: \"get_item\"\n      }), \" (we define). On the \", _jsx(_components.code, {\n        children: \"Item\"\n      }), \" struct we'll implement the required traits (\", _jsx(_components.code, {\n        children: \"PartialEq\"\n      }), \", \", _jsx(_components.code, {\n        children: \"PartialOrd\"\n      }), \", \", _jsx(_components.code, {\n        children: \"Ord\"\n      }), \") so that it can be inserted into min-heap:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [\"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"impl\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \"'a\"\n        }), \"\u003e \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"PartialEq\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Item\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \"'a\"\n        }), \"\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"eq\"\n        }), \"(\u0026\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \", other: \u0026\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"Self\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"-\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"bool\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"get_item\"\n        }), \"() == other.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"get_item\"\n        }), \"()\\n    }\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"impl\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \"'a\"\n        }), \"\u003e \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"PartialOrd\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Item\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \"'a\"\n        }), \"\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"partial_cmp\"\n        }), \"(\u0026\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \", other: \u0026\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"Self\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"-\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Option\"\n        }), \"\u003cOrdering\u003e {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"get_item\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"partial_cmp\"\n        }), \"(\u0026other.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"get_item\"\n        }), \"())\\n    }\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"impl\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \"'a\"\n        }), \"\u003e \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Ord\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Item\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \"'a\"\n        }), \"\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"cmp\"\n        }), \"(\u0026\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \", other: \u0026\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"Self\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"-\u003e\"\n        }), \" Ordering {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"get_item\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"cmp\"\n        }), \"(\u0026other.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"get_item\"\n        }), \"())\\n    }    \\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We also have a few helper methods \", _jsx(_components.code, {\n        children: \"new\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"get_item\"\n      }), \" purely for convenience.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"impl\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \"'a\"\n        }), \"\u003e Item\u003c\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \"'a\"\n        }), \"\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"new\"\n        }), \"(arr: \u0026\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \"'a\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Vec\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"i32\"\n        }), \"\u003e, idx: \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"usize\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"-\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"Self\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"Self\"\n        }), \" {\\n            arr,\\n            idx\\n        }\\n    }\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get_item\"\n        }), \"(\u0026\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"-\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"i32\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".arr[\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".idx]\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Once we have the required traits implemented for \", _jsx(_components.code, {\n        children: \"Item\"\n      }), \", we'll then implement the new \", _jsx(_components.code, {\n        children: \"merge\"\n      }), \" algorithm:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"use\"\n        }), \" std::collections::BinaryHeap;\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"use\"\n        }), \" std::cmp::Reverse;\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"use\"\n        }), \" std::cmp::Ordering;\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"merge\"\n        }), \"(arrays: \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Vec\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Vec\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"i32\"\n        }), \"\u003e\u003e) \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"-\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Vec\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"i32\"\n        }), \"\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"mut \"\n        }), _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"sorted\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"vec!\"\n        }), \"[];\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"mut \"\n        }), _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"heap\"\n        }), \" = BinaryHeap::\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"with_capacity\"\n        }), \"(arrays.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"len\"\n        }), \"());\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"arr\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \u0026arrays {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\"\n        }), _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"item\"\n        }), \" = Item::\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"new\"\n        }), \"(arr, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n        heap.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"push\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"Reverse\"\n        }), \"(item));\\n    }\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" !heap.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"is_empty\"\n        }), \"() {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"mut \"\n        }), _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"it\"\n        }), \" = heap.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"pop\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"unwrap\"\n        }), \"();\\n        sorted.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"push\"\n        }), \"(it.\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"get_item\"\n        }), \"());\\n        it.\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \".idx += \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" it.\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \".idx \u003c it.\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \".arr.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"len\"\n        }), \"() {\\n            heap.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"push\"\n        }), \"(it)\\n        }\\n    }\\n\\n    sorted\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We create a \", _jsx(_components.code, {\n        children: \"Vec\"\n      }), \" that will hold our merged items. We then create a \", _jsx(_components.code, {\n        children: \"BinaryHeap\"\n      }), \" instance and push all items in \", _jsx(_components.code, {\n        children: \"arrays\"\n      }), \" as an \", _jsx(_components.code, {\n        children: \"Item\"\n      }), \" with the start index \", _jsx(_components.code, {\n        children: \"0\"\n      }), \". We then wrap \", _jsx(_components.code, {\n        children: \"item\"\n      }), \" with \", _jsx(_components.code, {\n        children: \"Reverse\"\n      }), \" (as it's a max heap by default) and push it to heap.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Next, we run a loop while we still have elements in heap. Within the loop, we get the smallest item by \", _jsx(_components.code, {\n        children: \"heap.pop()\"\n      }), \" and push it to \", _jsx(_components.code, {\n        children: \"sorted\"\n      }), \" and increment the item's index by 1. Because we might still have items in the heap, we check for that and push it back in the last line.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Finally once we are done, we return the \", _jsx(_components.code, {\n        children: \"sorted\"\n      }), \" array.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For this solution our complexity now reduces to `O(n*k * Log(k))\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Finally let's test this out on a sample dataset:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"() {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\"\n        }), _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"a\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"vec!\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"7\"\n        }), \"];\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\"\n        }), _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"b\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"vec!\"\n        }), \"[-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \"];\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\"\n        }), _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"v\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"vec!\"\n        }), \"[a, b];\\n    dbg!(\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"merge\"\n        }), \"(v));\\n}\\n\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Final code: https://gist.github.com/creativcoder/20fda0f1a947bf2af3b93ab394d6bacb\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"taking-it-a-step-further\",\n      children: _jsx(_components.a, {\n        href: \"#taking-it-a-step-further\",\n        children: \"Taking it a step further\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"An optimization on top of this would be to stream sorted values as they are processed by exposing an iterator over the \", _jsx(_components.code, {\n        children: \"k\"\n      }), \" items in heap.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"With that said, I am open to suggestions, improvements to the solution and you can do so with comments below. Until next time!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"meta":{"excerpt":"An explanation and implementation blog post in Rust","slug":"merge-k-sorted-arrays-rust","title":"Merge k sorted arrays in Rust","tags":["algorithms","databases","key-value","merge"],"date":"Mon Dec 07 2020 05:30:00 GMT+0530 (India Standard Time)","author":"creativcoder","readingTime":"9min"}}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"merge-k-sorted-arrays-rust"},"buildId":"C0oqtusQj9cY-EdwLN_RL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>