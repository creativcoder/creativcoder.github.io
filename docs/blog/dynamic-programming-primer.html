<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>creativcoder</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/ab2a2959b9ba8661.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ab2a2959b9ba8661.css" data-n-g=""/><link rel="preload" href="/_next/static/css/f16eaa9e44b97d3f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f16eaa9e44b97d3f.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-9faa89de3ee6e754.js" defer=""></script><script src="/_next/static/chunks/framework-a87821de553db91d.js" defer=""></script><script src="/_next/static/chunks/main-32a43e1092778ede.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2e588ff4f55f23af.js" defer=""></script><script src="/_next/static/chunks/167-4ae4480dee839e87.js" defer=""></script><script src="/_next/static/chunks/675-f43734e7770ea31e.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-c606869ed04a3d0b.js" defer=""></script><script src="/_next/static/C0oqtusQj9cY-EdwLN_RL/_buildManifest.js" defer=""></script><script src="/_next/static/C0oqtusQj9cY-EdwLN_RL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="" style="position:fixed;top:0;left:0;height:3px;background:transparent;z-index:99999999999;width:100%"><div class="" style="height:100%;background:#4CE0B3;transition:all 500ms ease;width:0%"><div style="box-shadow:0 0 10px #4CE0B3, 0 0 10px #4CE0B3;width:5%;opacity:1;position:absolute;height:100%;transition:all 500ms ease;transform:rotate(3deg) translate(0px, -4px);left:-10rem"></div></div></div><div class="flex min-h-screen w-screen overflow-hidden flex-col items-center dark:bg-[#242729] bg-slate-200 backdrop" style="opacity:0.5;background-color:#E2E8F0"><div class="max-w-2xl md:max-w-3xl lg:max-w-4xl space-y-12 w-screen sticky"><nav class="bg-[#f6f8f9] dark:bg-[#2b2e30] dark:shadow-md m-3 rounded-lg shadow-sm backdrop-filter backdrop-blur-md bg-opacity-40 sticky top-0 mt-10"><div class="mx-auto p-4"><div class="flex justify-between"><div class="cursor-pointer flex space-x-2 items-center"><div><img src="/logo_v3.svg" width="26" class="pt-0.5 invert"/></div><div class="text-lg dark:text-white hidden md:block">creativcoder</div></div><div class="flex items-center pr-2"><ul class="hidden md:flex md:space-x-4 pr-3"><a class="hover:text-slate-500 dark:text-slate-200 text-slate-700 transition flex items-center" href="/blog"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M18.404 2.998c-.757-.754-2.077-.751-2.828.005l-1.784 1.791L11.586 7H7a.998.998 0 0 0-.939.658l-4 11c-.133.365-.042.774.232 1.049l2 2a.997.997 0 0 0 1.049.232l11-4A.998.998 0 0 0 17 17v-4.586l2.207-2.207v-.001h.001L21 8.409c.378-.378.586-.881.585-1.415 0-.535-.209-1.038-.588-1.415l-2.593-2.581zm-3.111 8.295A.996.996 0 0 0 15 12v4.3l-9.249 3.363 4.671-4.671c.026.001.052.008.078.008A1.5 1.5 0 1 0 9 13.5c0 .026.007.052.008.078l-4.671 4.671L7.7 9H12c.266 0 .52-.105.707-.293L14.5 6.914 17.086 9.5l-1.793 1.793zm3.206-3.208-2.586-2.586 1.079-1.084 2.593 2.581-1.086 1.089z"></path></svg></a><a class="hover:text-slate-500 dark:text-slate-200 text-slate-700 transition flex items-center" href="https://youtube.com/@creativcoder"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="24" width="24" xmlns="http://www.w3.org/2000/svg"><g><path fill="none" d="M0 0h24v24H0z"></path><path fill-rule="nonzero" d="M19.606 6.995c-.076-.298-.292-.523-.539-.592C18.63 6.28 16.5 6 12 6s-6.628.28-7.069.403c-.244.068-.46.293-.537.592C4.285 7.419 4 9.196 4 12s.285 4.58.394 5.006c.076.297.292.522.538.59C5.372 17.72 7.5 18 12 18s6.629-.28 7.069-.403c.244-.068.46-.293.537-.592C19.715 16.581 20 14.8 20 12s-.285-4.58-.394-5.005zm1.937-.497C22 8.28 22 12 22 12s0 3.72-.457 5.502c-.254.985-.997 1.76-1.938 2.022C17.896 20 12 20 12 20s-5.893 0-7.605-.476c-.945-.266-1.687-1.04-1.938-2.022C2 15.72 2 12 2 12s0-3.72.457-5.502c.254-.985.997-1.76 1.938-2.022C6.107 4 12 4 12 4s5.896 0 7.605.476c.945.266 1.687 1.04 1.938 2.022zM10 15.5v-7l6 3.5-6 3.5z"></path></g></svg></a><a class="hover:text-slate-500 dark:text-slate-200 text-slate-700 transition flex items-center" href="/about"><svg stroke="currentColor" fill="none" stroke-width="0" viewBox="0 0 24 24" height="24" width="24" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M16 9C16 11.2091 14.2091 13 12 13C9.79086 13 8 11.2091 8 9C8 6.79086 9.79086 5 12 5C14.2091 5 16 6.79086 16 9ZM14 9C14 10.1046 13.1046 11 12 11C10.8954 11 10 10.1046 10 9C10 7.89543 10.8954 7 12 7C13.1046 7 14 7.89543 14 9Z" fill="currentColor"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1ZM3 12C3 14.0902 3.71255 16.014 4.90798 17.5417C6.55245 15.3889 9.14627 14 12.0645 14C14.9448 14 17.5092 15.3531 19.1565 17.4583C20.313 15.9443 21 14.0524 21 12C21 7.02944 16.9706 3 12 3C7.02944 3 3 7.02944 3 12ZM12 21C9.84977 21 7.87565 20.2459 6.32767 18.9878C7.59352 17.1812 9.69106 16 12.0645 16C14.4084 16 16.4833 17.1521 17.7538 18.9209C16.1939 20.2191 14.1881 21 12 21Z" fill="currentColor"></path></svg></a></ul><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="md:hidden block"><path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path></svg></div></div></div></nav><div><article class="dark:text-slate-200 dark:prose-headings:text-slate-200 dark:prose-code:text-slate-200 dark:prose-blockquote:text-slate-200 dark:prose-strong:text-slate-100 dark:prose-pre:bg-zinc-900 dark:prose-pre:shadow-md dark:prose-pre:border-gray-600 dark:prose-pre:border-[1.4px] dark:prose-a:text-slate-200 prose prose-xl flex flex-col mx-auto max-w-6xl justify-center pl-6 pr-6 prose-p:m-3 prose-headings:mb-3 prose-headings:mt-3 prose-a:font-bold prose-img:rounded-lg prose-img:m-auto prose-img:w-full prose-img:shadow-lg prose-code:font-jetbrains prose-pre:p-0 prose-a:no-underline prose-h1:text-4xl prose-h1:pl-2 prose-h2:pl-2 prose-blockquote:border-slate-600 prose-h2:text-xl"><div class="flex flex-col"><p class="text-4xl font-bold">Dynamic programming primer</p><div class="pt-3 flex justify-between flex-row-reverse"><div class="flex items-center space-x-2"><p class="text-sm">3rd January 2017</p></div><div class="flex items-center space-x-2"><p class="text-sm tracking-wide">creativcoder<!-- --> / <!-- -->6min<!-- --></p></div></div><div class="flex justify-center"><hr class="mb-8 h-px bg-gray-400 border-0 dark:bg-gray-500 w-full"/></div></div><blockquote>
<!-- --><p><em>&quot;A complex entity is a combinatoric amalgamation of simple loosely coupled pieces&quot;</em></p>
<!-- --></blockquote>
<!-- --><p><img src="http://i.imgur.com/IaiXuwh.jpg" alt="coverImage"/></p>
<!-- --><p>Dynamic programming (DP for brevity) while being widely applicable to a lot of computer science problems is often talked about being complicated to understand. This post tries to uncover the fundamental ideas behind them. This article is aimed for beginners so experienced readers may not find it trivial. As always suggestions and improvements are welcome.</p>
<!-- --><p>Dynamic programming gives you the ability think problems bottom up rather than more natural and intuitive top down thinking that most of us use. Let me tell you that the bottom up thinking approach won&#x27;t come readily from just solving one or two problems, you really have to practice a lot of problems of this kind to wire it properly to your thinking and even prior to solving problems using DP we should know one thing that not all problems exhibit a DP based solution the reasons for which you discover later in the article.</p>
<!-- --><p>I myself was a bit vague on the principles of dynamic programming but with dedicated readings from the last few months I have been able to make sense of DP and this blog post is a step towards consolidating my understanding.</p>
<!-- --><p>So with the intro aside, let&#x27;s dive in. Let&#x27;s get to the essence of Dynamic Programming!</p>
<!-- --><p>Many articles starts explaining dynamic programming by introducing the fibonacci sequence to the readers. We will eventually get there but before that I want to explore a more trivial example to really see the nature of problems that we encounter everyday and how it closely resembles the thinking behind dynamic programming.</p>
<!-- --><p>We&#x27;ll try to find DP in integer sequences. (From the perspective of an experienced DP guy, this is not a very convincing example as it does not have overlapping subproblems, but I wanted a more trivial example.)</p>
<!-- --><p>Consider the problem of generating non-negative integer sequences.</p>
<!-- --><p>Let us ask ourselves how can we form the number 7?
Although there are more than one possible answer to this. Lets take one solution to it:
7 = 6 + 1.</p>
<!-- --><p>So you see 7 can be formed by taking the previous number 6 and adding 1 to it. Similary you can intuit that 6 can be formed by using 5 and adding 1 to it and so on.</p>
<!-- --><p>In this case, the problem of making the number 7 is split into two subproblems:</p>
<!-- --><ul>
<!-- --><li>Making 6</li>
<!-- --><li>Adding 1 to it</li>
<!-- --></ul>
<!-- --><p>This brings us to the concept of a subproblem.</p>
<!-- --><p><strong>Subproblem</strong> - A subproblem S(n) is a self contained solution state towards a larger problem. In the above trivial example on integers, the subproblem for getting the number 7 is: (Problem of getting the number 6) + 1. Similarly, Problem of getting the number 6: (Problem of getting number 5) + 1.<!-- --></p>
<!-- --><p>To generalize for the above problem, n can be solved by solving (n-1) and adding 1 to it. But in DP, we approach it from the opposite side. To get to the solution 7, we start with a base case solution S(0) =  0 (well zero can be constructed by having only 1 zero), then we construct the next solution to the subproblem S(1) = S[0] + 1. Then S(2) = S[1] + 1, then S(3) = S[2] + 1 until we reach S(7) = S[6] + 1. Notice the square brackets when we are building the next solution. It means that we are using the previous solution which was already calculated before.</p>
<!-- --><p>Having made the concept of a subproblem clear, let&#x27;s get to our fibonacci example which most of you should be familiar with. Here&#x27;s a formal definition:</p>
<!-- --><pre><code class="hljs language-python">f(n) = f(n-<!-- --><span class="hljs-number">1</span>) + f(n-<!-- --><span class="hljs-number">2</span>)        where n[<!-- --><span class="hljs-number">0</span>] = <!-- --><span class="hljs-number">0</span> <!-- --><span class="hljs-keyword">and</span> n[<!-- --><span class="hljs-number">1</span>] = <!-- --><span class="hljs-number">1</span>
<!-- --></code></pre>
<!-- --><p>Lets map the concepts we learned from our previous example.</p>
<!-- --><p>Here <!-- --><code>n[0]</code> and <!-- --><code>n[1]</code> are base cases. <!-- --><code>f(n)</code> is the instance of the problem we are trying to solve and by its definition <!-- --><code>f(n-1)</code> and <!-- --><code>f(n-2)</code> are the subproblems which when added gives the solution to f(n).<!-- --></p>
<!-- --><p>There is a straight forward recursive approach, to solve fibonacci sequences.</p>
<!-- --><p>A python example:</p>
<!-- --><pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <!-- --><span class="hljs-title function_">fib</span>(<!-- --><span class="hljs-params">n</span>):
  <!-- --><span class="hljs-keyword">if</span> n == <!-- --><span class="hljs-number">0</span> <!-- --><span class="hljs-keyword">or</span> n == <!-- --><span class="hljs-number">1</span>:
    <!-- --><span class="hljs-keyword">return</span> n
  <!-- --><span class="hljs-keyword">return</span> fib(n-<!-- --><span class="hljs-number">1</span>)+fib(n-<!-- --><span class="hljs-number">2</span>)
<!-- --></code></pre>
<!-- --><p>If we explicitely list out the solution to f(7):</p>
<!-- --><pre><code class="hljs language-python">f(<!-- --><span class="hljs-number">7</span>) = f(<!-- --><span class="hljs-number">6</span>) + f(<!-- --><span class="hljs-number">5</span>)
  (A)    (B)
<!-- --></code></pre>
<!-- --><p>Lets also expand A and B</p>
<!-- --><pre><code class="hljs language-python">A: f(<!-- --><span class="hljs-number">6</span>) = f(<!-- --><span class="hljs-number">5</span>) + f(<!-- --><span class="hljs-number">4</span>)
B: f(<!-- --><span class="hljs-number">5</span>) = f(<!-- --><span class="hljs-number">4</span>) + f(<!-- --><span class="hljs-number">3</span>)
<!-- --></code></pre>
<!-- --><p>Now there&#x27;s an interesting observation branching of the problem into two subproblems. We are recalcuting at least one thing in the next subproblem that we already calculated in previous levels. An example of this would be : <!-- --><code>f(5)</code> is calculated in <!-- --><code>f(7)</code> branching, but it&#x27;s also calculated in <!-- --><code>f(6)</code> branching. This redundant recalculation continues at all levels of branches, resulting in a worst case complexity of <!-- --><code>2^n</code>. As a result, this solution takes a lot of time to run for queries such as <!-- --><code>f(40)</code> or <!-- --><code>f(100)</code>.<!-- --></p>
<!-- --><p>This fibonacci problem shows us two attributes which are characteristics for knowing if a DP solution can be applied to a problem:</p>
<!-- --><ol>
<!-- --><li>
<!-- --><p><strong>Overlapping subproblems</strong> - As explained above on the branching of function calls, we are re-calculating many things that have been calculated before. The fibonacci example shows that there are same subproblems that are overlapping or recalculated at many levels.<!-- --></p>
<!-- --></li>
<!-- --><li>
<!-- --><p><strong>Optimal substructure</strong> - This simply means that, optimal solutions to smaller sub problems gives the solution to the larger problem. The fibonacci example does help in depicting this, but this can be seen in algorithms such as the Shortest Path Problem, where we must need a shortest path for the subproblems to get the overall shortest path.<!-- --></p>
<!-- --></li>
<!-- --></ol>
<!-- --><p>So the problem of finding Fibonacci numbers can indeed be solved using DP.</p>
<!-- --><p>But it can be done in two ways:</p>
<!-- --><ul>
<!-- --><li>Top down</li>
<!-- --><li>Bottom up</li>
<!-- --></ul>
<!-- --><p>Let&#x27;s take a look at the top down approach, also know as memoization.</p>
<!-- --><blockquote>
<!-- --><p>The term &quot;memoization&quot; was introduced by Donald Michie in the year 1968. It&#x27;s based on the Latin word memorandum which means &quot;to be remembered&quot;.</p>
<!-- --></blockquote>
<!-- --><pre><code class="hljs language-python">cache = {}
<!-- --><span class="hljs-keyword">def</span> <!-- --><span class="hljs-title function_">fibonacci_memo</span>(<!-- --><span class="hljs-params">n</span>):
    <!-- --><span class="hljs-keyword">if</span> n &lt; <!-- --><span class="hljs-number">2</span>:
        cache[n] = n
        <!-- --><span class="hljs-keyword">return</span> n
    <!-- --><span class="hljs-keyword">elif</span> n <!-- --><span class="hljs-keyword">not</span> <!-- --><span class="hljs-keyword">in</span> cache:
        cache[n] = fibonacci_memo(n-<!-- --><span class="hljs-number">1</span>) + fibonacci_memo(n-<!-- --><span class="hljs-number">2</span>)
    <!-- --><span class="hljs-keyword">return</span> cache[n]
<!-- --></code></pre>
<!-- --><p>So what did we just do? We just added a <!-- --><code>cache</code> dictionary to store the computed values. Then for the given query <!-- --><code>n</code>, our cache method will return results from our cache rather than re-computing it, If it does not exist<!-- --></p>
<!-- --><p>And here&#x27;s our bottom up approach:</p>
<!-- --><pre><code class="hljs language-python">cache = {}
<!-- --><span class="hljs-keyword">def</span> <!-- --><span class="hljs-title function_">fibonacci_dp</span>(<!-- --><span class="hljs-params">n</span>):
  <!-- --><span class="hljs-keyword">if</span> n &lt; <!-- --><span class="hljs-number">2</span>:
    cache[n] = n
    <!-- --><span class="hljs-keyword">return</span> n
  <!-- --><span class="hljs-keyword">else</span>:
    <!-- --><span class="hljs-keyword">for</span> i <!-- --><span class="hljs-keyword">in</span> <!-- --><span class="hljs-built_in">range</span>(<!-- --><span class="hljs-number">2</span>, n):
      cache[i] = cache[i-<!-- --><span class="hljs-number">1</span>] +c ache[i-<!-- --><span class="hljs-number">2</span>]
  <!-- --><span class="hljs-keyword">return</span> cache[n]
<!-- --></code></pre>
<!-- --><p>In the bottom up approach, we construct our solution optimally from the base cases and work our way up until we reach to the given <!-- --><code>n</code>. This approach cuts down our overhead of making function calls and creating new stack frames.<!-- --></p>
<!-- --><p>So to summerize our understanding, Dynamic programming is:</p>
<!-- --><ol>
<!-- --><li>
<!-- --><p>Splitting our problem into subproblem and identifying if the subproblems are overlapping.</p>
<!-- --></li>
<!-- --><li>
<!-- --><p>Solving the sub problems optimally and saving it and try it on a larger problem to see if we are getting the desired solution to the larger problem.</p>
<!-- --></li>
<!-- --></ol>
<!-- --><p>DP is not some definite algorithm, but consider it as a meta algorithm that allows you to minimize the runtime complexity of your existing algorithm that you have thought of by identifying and eliminating redundant parts of it.</p>
<!-- --><p><em>Richard Bellman</em> who theorized DP in his paper describes it as a decision guiding principle in a problem where we have several states of a problem and we wish to maximize the outcome of the problem. It is an algorithm optimization technique.<!-- --></p>
<!-- --><p>If you want to dive deeper into the roots of it, consider reading this paper <!-- --><strong>http://smo.sogang.ac.kr/doc/bellman.pdf</strong> by Richard.<!-- --></p>
<!-- --><p>So that was basically it about dynamic programming. In the next post on this topic, we will see another DP problem by introducing the coin change problem.</p>
<!-- --><p>Cheers :)</p><div class="flex justify-center"><hr class="mb-8 h-px bg-gray-400 border-0 dark:bg-gray-500 w-full"/></div><p class="text-sm font-bold">Want to share feedback, or discuss further ideas? Feel free to leave a comment here! Please follow Rust&#x27;s code of conduct. This comment thread directly maps to a discussion on GitHub, so you can also comment there if you prefer.</p></article>;<!-- --></div><footer class="flex flex-col items-center w-full"><div class="px-4 py-2 flex items-center justify-center space-x-2 border-2 rounded-md border-gray-500 hover:bg-blue-100 transition-colors hover:text-lime-900"><svg stroke="currentColor" fill="currentColor" stroke-width="0" role="img" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><title></title><path d="M17.625 1.499c-2.32 0-4.354 1.203-5.625 3.03-1.271-1.827-3.305-3.03-5.625-3.03C3.129 1.499 0 4.253 0 8.249c0 4.275 3.068 7.847 5.828 10.227a33.14 33.14 0 0 0 5.616 3.876l.028.017.008.003-.001.003c.163.085.342.126.521.125.179.001.358-.041.521-.125l-.001-.003.008-.003.028-.017a33.14 33.14 0 0 0 5.616-3.876C20.932 16.096 24 12.524 24 8.249c0-3.996-3.129-6.75-6.375-6.75zm-.919 15.275a30.766 30.766 0 0 1-4.703 3.316l-.004-.002-.004.002a30.955 30.955 0 0 1-4.703-3.316c-2.677-2.307-5.047-5.298-5.047-8.523 0-2.754 2.121-4.5 4.125-4.5 2.06 0 3.914 1.479 4.544 3.684.143.495.596.797 1.086.796.49.001.943-.302 1.085-.796.63-2.205 2.484-3.684 4.544-3.684 2.004 0 4.125 1.746 4.125 4.5 0 3.225-2.37 6.216-5.048 8.523z"></path></svg><p>Be a GitHub Sponser</p></div><div class="flex-col items-center justify-center mt-8 mb-8"><div class="text-center text-xs mx-auto">© 2016-<!-- -->2022<!-- --> creativcoder. All rights reserved.<!-- --></div></div></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    blockquote: \"blockquote\",\n    p: \"p\",\n    em: \"em\",\n    img: \"img\",\n    ul: \"ul\",\n    li: \"li\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    ol: \"ol\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"\\\"A complex entity is a combinatoric amalgamation of simple loosely coupled pieces\\\"\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"http://i.imgur.com/IaiXuwh.jpg\",\n        alt: \"coverImage\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Dynamic programming (DP for brevity) while being widely applicable to a lot of computer science problems is often talked about being complicated to understand. This post tries to uncover the fundamental ideas behind them. This article is aimed for beginners so experienced readers may not find it trivial. As always suggestions and improvements are welcome.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Dynamic programming gives you the ability think problems bottom up rather than more natural and intuitive top down thinking that most of us use. Let me tell you that the bottom up thinking approach won't come readily from just solving one or two problems, you really have to practice a lot of problems of this kind to wire it properly to your thinking and even prior to solving problems using DP we should know one thing that not all problems exhibit a DP based solution the reasons for which you discover later in the article.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I myself was a bit vague on the principles of dynamic programming but with dedicated readings from the last few months I have been able to make sense of DP and this blog post is a step towards consolidating my understanding.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So with the intro aside, let's dive in. Let's get to the essence of Dynamic Programming!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Many articles starts explaining dynamic programming by introducing the fibonacci sequence to the readers. We will eventually get there but before that I want to explore a more trivial example to really see the nature of problems that we encounter everyday and how it closely resembles the thinking behind dynamic programming.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We'll try to find DP in integer sequences. (From the perspective of an experienced DP guy, this is not a very convincing example as it does not have overlapping subproblems, but I wanted a more trivial example.)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Consider the problem of generating non-negative integer sequences.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let us ask ourselves how can we form the number 7?\\nAlthough there are more than one possible answer to this. Lets take one solution to it:\\n7 = 6 + 1.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So you see 7 can be formed by taking the previous number 6 and adding 1 to it. Similary you can intuit that 6 can be formed by using 5 and adding 1 to it and so on.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In this case, the problem of making the number 7 is split into two subproblems:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Making 6\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Adding 1 to it\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This brings us to the concept of a subproblem.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Subproblem\"\n      }), \" - A subproblem S(n) is a self contained solution state towards a larger problem. In the above trivial example on integers, the subproblem for getting the number 7 is: (Problem of getting the number 6) + 1. Similarly, Problem of getting the number 6: (Problem of getting number 5) + 1.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To generalize for the above problem, n can be solved by solving (n-1) and adding 1 to it. But in DP, we approach it from the opposite side. To get to the solution 7, we start with a base case solution S(0) =  0 (well zero can be constructed by having only 1 zero), then we construct the next solution to the subproblem S(1) = S[0] + 1. Then S(2) = S[1] + 1, then S(3) = S[2] + 1 until we reach S(7) = S[6] + 1. Notice the square brackets when we are building the next solution. It means that we are using the previous solution which was already calculated before.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Having made the concept of a subproblem clear, let's get to our fibonacci example which most of you should be familiar with. Here's a formal definition:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [\"f(n) = f(n-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \") + f(n-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \")        where n[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"] = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"and\"\n        }), \" n[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"] = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Lets map the concepts we learned from our previous example.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here \", _jsx(_components.code, {\n        children: \"n[0]\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"n[1]\"\n      }), \" are base cases. \", _jsx(_components.code, {\n        children: \"f(n)\"\n      }), \" is the instance of the problem we are trying to solve and by its definition \", _jsx(_components.code, {\n        children: \"f(n-1)\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"f(n-2)\"\n      }), \" are the subproblems which when added gives the solution to f(n).\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There is a straight forward recursive approach, to solve fibonacci sequences.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"A python example:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fib\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"n\"\n        }), \"):\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" n == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"or\"\n        }), \" n == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \":\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" fib(n-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")+fib(n-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If we explicitely list out the solution to f(7):\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [\"f(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"7\"\n        }), \") = f(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \") + f(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \")\\n  (A)    (B)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Lets also expand A and B\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [\"A: f(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \") = f(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \") + f(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \")\\nB: f(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \") = f(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \") + f(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now there's an interesting observation branching of the problem into two subproblems. We are recalcuting at least one thing in the next subproblem that we already calculated in previous levels. An example of this would be : \", _jsx(_components.code, {\n        children: \"f(5)\"\n      }), \" is calculated in \", _jsx(_components.code, {\n        children: \"f(7)\"\n      }), \" branching, but it's also calculated in \", _jsx(_components.code, {\n        children: \"f(6)\"\n      }), \" branching. This redundant recalculation continues at all levels of branches, resulting in a worst case complexity of \", _jsx(_components.code, {\n        children: \"2^n\"\n      }), \". As a result, this solution takes a lot of time to run for queries such as \", _jsx(_components.code, {\n        children: \"f(40)\"\n      }), \" or \", _jsx(_components.code, {\n        children: \"f(100)\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This fibonacci problem shows us two attributes which are characteristics for knowing if a DP solution can be applied to a problem:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Overlapping subproblems\"\n          }), \" - As explained above on the branching of function calls, we are re-calculating many things that have been calculated before. The fibonacci example shows that there are same subproblems that are overlapping or recalculated at many levels.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Optimal substructure\"\n          }), \" - This simply means that, optimal solutions to smaller sub problems gives the solution to the larger problem. The fibonacci example does help in depicting this, but this can be seen in algorithms such as the Shortest Path Problem, where we must need a shortest path for the subproblems to get the overall shortest path.\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So the problem of finding Fibonacci numbers can indeed be solved using DP.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But it can be done in two ways:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Top down\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Bottom up\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's take a look at the top down approach, also know as memoization.\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"The term \\\"memoization\\\" was introduced by Donald Michie in the year 1968. It's based on the Latin word memorandum which means \\\"to be remembered\\\".\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [\"cache = {}\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fibonacci_memo\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"n\"\n        }), \"):\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" n \u003c \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \":\\n        cache[n] = n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"elif\"\n        }), \" n \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"not\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" cache:\\n        cache[n] = fibonacci_memo(n-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \") + fibonacci_memo(n-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \")\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" cache[n]\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So what did we just do? We just added a \", _jsx(_components.code, {\n        children: \"cache\"\n      }), \" dictionary to store the computed values. Then for the given query \", _jsx(_components.code, {\n        children: \"n\"\n      }), \", our cache method will return results from our cache rather than re-computing it, If it does not exist\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And here's our bottom up approach:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [\"cache = {}\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fibonacci_dp\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"n\"\n        }), \"):\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" n \u003c \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \":\\n    cache[n] = n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \":\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" i \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"range\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \", n):\\n      cache[i] = cache[i-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"] +c ache[i-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \"]\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" cache[n]\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In the bottom up approach, we construct our solution optimally from the base cases and work our way up until we reach to the given \", _jsx(_components.code, {\n        children: \"n\"\n      }), \". This approach cuts down our overhead of making function calls and creating new stack frames.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So to summerize our understanding, Dynamic programming is:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Splitting our problem into subproblem and identifying if the subproblems are overlapping.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Solving the sub problems optimally and saving it and try it on a larger problem to see if we are getting the desired solution to the larger problem.\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"DP is not some definite algorithm, but consider it as a meta algorithm that allows you to minimize the runtime complexity of your existing algorithm that you have thought of by identifying and eliminating redundant parts of it.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.em, {\n        children: \"Richard Bellman\"\n      }), \" who theorized DP in his paper describes it as a decision guiding principle in a problem where we have several states of a problem and we wish to maximize the outcome of the problem. It is an algorithm optimization technique.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you want to dive deeper into the roots of it, consider reading this paper \", _jsx(_components.strong, {\n        children: \"http://smo.sogang.ac.kr/doc/bellman.pdf\"\n      }), \" by Richard.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So that was basically it about dynamic programming. In the next post on this topic, we will see another DP problem by introducing the coin change problem.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Cheers :)\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"meta":{"excerpt":"An intuitive guide on the basics","slug":"dynamic-programming-primer","title":"Dynamic programming primer","tags":["algorithms","beginner","dynamic-programming","optimization"],"date":"Tue Jan 03 2017 05:30:00 GMT+0530 (India Standard Time)","author":"creativcoder","readingTime":"6min"}}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"dynamic-programming-primer"},"buildId":"C0oqtusQj9cY-EdwLN_RL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>