{"pageProps":{"post":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    a: \"a\",\n    code: \"code\",\n    pre: \"pre\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://images.unsplash.com/photo-1531765408077-9a1f85f90df1?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1173&q=80\",\n        alt: \"cover image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I have seen many of my peers ask from time to time, what is http, and how it works.\\nAlso as a web developer understanding HTTP protocol is an essential asset to be able to think in a way, as to how to architecture your web apps, so that it follows the semantics of HTTP.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This post will discuss on the abstraction/medium on which the 'user facing' internet stands on.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"A bit of background first!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Similar to how we as humans need a language with a structure to communicate and exchange ideas effectively among our peers; computers need to talk to different computers over a network. And being dumb machines, they need every detail communicated in the message in a precise manner.\\nHTTP is just that language through which computers can talk to other remote computers over a network.\\nTechnically speaking, HTTP is a request/response based, stateless (will come to this on a follow up post) application layer protocol, implemented on top of a stateful protcol which is TCP/IP usually.\\nTCP/IP is another lower layer of abstraction for communicating bytes reliably over the network.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In the same way how our english sentences have a formal structure and semantic; the HTTP protocol also has a formal description of it, usually defined in a spec sheet, called \", _jsx(_components.a, {\n        href: \"https://www.ietf.org/rfc.html\",\n        children: \"RFC\"\n      }), \"'s (Request for Comments).\\nThese are standardized documents, that are accepted globally and maintained by IETF(Internet Engineering Task Force).\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The HTTP's \", _jsx(_components.a, {\n        href: \"https://www.rfc-editor.org/rfc/rfc2616.txt\",\n        children: \"RFC\"\n      }), \" describes in details, every aspect of the request reponse cycle, that can happen over when two machines are communicating over HTTP, how the message will be parsed, what sort of security aspects to employ when sending the message, etc., and these are then implemented by servers and clients ( usually web browsers ), using a programming language based on the infrastructure and needs. The choice of language, is independent, as HTTP specification is language agnostic.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So a server that, is able to speak the http protocol is called an HTTP Server.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Examples of http servers are \", _jsx(_components.a, {\n        href: \"https://www.nginx.com\",\n        children: \"nginx\"\n      }), \", \", _jsx(_components.a, {\n        href: \"http://www.apache.org\",\n        children: \"apache\"\n      }), \", etc.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"and similarly, a client which is able to speak the http protcol, is called an Http Client.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Examples of http clients are \", _jsx(_components.a, {\n        href: \"https://curl.haxx.se/\",\n        children: \"cURL\"\n      }), \" (command line http client), python \", _jsx(_components.a, {\n        href: \"https://pypi.python.org/pypi/requests\",\n        children: \"requests\"\n      }), \" library and ofcourse web browsers.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now with that explained, we are at the point to see some actual HTTP message.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In HTTP, there are two parts of communication.\\nOne is the request part, which is sent by http-clients, and the other is the response part, which is sent back by the servers on getting a http request.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now before we see any actual message, let us understand what a resource means in http.\\nUnder HTTP, anything that we want to communicate to and fro or query for, with the remote machine is generally termed as a Resource.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So lets see how, how do you say 'hi' in http. (the request part of HTTP Communication)\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Before that, lets fire up a socket server in python over TCP, so that we can see what, http request mesage we are receiving from our browser(an http client). We will expand our server further to respond to our browser with a 'hey hi client', when the request is \", _jsx(_components.code, {\n        children: \"/hi\"\n      }), \" in part 2 of this post.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" socket\\n\\nhost,port = (\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"''\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1313\"\n        }), \")\\n\\nlistener = socket.socket(socket.AF_INET,socket.SOCK_STREAM)\\nlistener.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")\\nlistener.bind((host,port))\\nlistener.listen(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Serving on port {}\\\"\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"format\"\n        }), \"(port))\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"True\"\n        }), \":\\n    client_conn,client_addr = listener.accept()\\n    request = client_conn.recv(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1024\"\n        }), \")\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \" request \\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We won't be diving much into the details of the python sockets connection mechanism, to keep the blog focused only on HTTP. I intend to do another blog post on sockets. To put it in brief, sockets are endpoints of communcation, or channels,(technically its a tuple of (ip_address,port) ) that forms a pathway for messages to be sent accross remote entities.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Save it as server.py, and do \", _jsx(_components.code, {\n        children: \"python server.py\"\n      }), \" to make it, start listening for requests on port 1313.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now head over to the web browser, and put the url : \", _jsx(_components.code, {\n        children: \"localhost:1313/hi\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Over your terminal window you will see something getting logged to standard output like this.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-bash\",\n        children: [\"GET /hi HTTP/1.1\\nHost: localhost:1313\\nConnection: keep-alive\\nAccept: text/html, application/xhtml, application/xml .... (omitted \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" brevity)\\nUser-Agent: Mozilla/5.0 (Windows NT 6.3) .... (omitted \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" brevity)\\nAccept-Encoding: gzip, deflate,sdch\\nAccept-Language: en-US,en;q=0.8\\nCookie: _ga=GA1.1.52864490.1449694093;__atuvc=27%7C7 ....\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"An http request starts a series of key value pairs, which in http parlance are known as \", _jsx(_components.code, {\n        children: \"header fields\"\n      }), \".Basically each key value pair stores a metadata about our request, which is important to let the server know, like information about which http client it will be talking to and what resource is the client asking for and other details. I will touch on a few header fields here.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The first line is of our concern here:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"GET /hi HTTP/1.1\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This says that, it is a \", _jsx(_components.code, {\n        children: \"GET\"\n      }), \" request, and the path to our resource resides at \", _jsx(_components.code, {\n        children: \"/hi\"\n      }), \", and next is the protcol that the client speaks which is \", _jsx(_components.code, {\n        children: \"HTTP/1.1\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The next line tells about, the \", _jsx(_components.code, {\n        children: \"host\"\n      }), \", which is \", _jsx(_components.code, {\n        children: \"localhost:1313\"\n      }), \". It serves as the information to the server, where to send the resposne back to. \", _jsx(_components.code, {\n        children: \"localhost\"\n      }), \" is our domain,\", _jsx(_components.code, {\n        children: \"1313\"\n      }), \", is our port number on which the server is listening to.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Note: Now web servers by convention, listen on port 80\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now before we talk about the next line, we need to know about the term \", _jsx(_components.code, {\n        children: \"stateless\"\n      }), \". As HTTP is a stateless protocol, each request and response cycle is not dependent on any previous request reponse. Every response that is made, is ignorant of the state of the server, or any previous request that was sent. I intend to have another blog post on stateless property of HTTP, so for the time being lets, keep it to this definition.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So the \", _jsx(_components.code, {\n        children: \"Connection: keep-alive\"\n      }), \" says, that we want to reuse the same tcp connection we established on the request, for further requests. As HTTP is stateless it closes the connection after every request it makes and so for every subsequent request, HTTP has to re-establish connection to the server.\\nIf this header field is present, this will try to minimize the the overhead of re-establising the tcp connection on further request. The time for connection keep alive, is usually specified when implementing the server, and also can be configured.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"User-Agent\"\n      }), \" header serves as another identity mechanism, to send different, representations of response message to the user. In this example, the user-agent is a Web browser. A mobile device will send a user agent ( for example \", _jsx(_components.code, {\n        children: \"Apple-iPhone4C1/902.206\"\n      }), \" is the user agent for an Apple iPhone4C ); that is different from a web browser becuase its different in terms of form factor, and various features. So accordingly that wil be served differently by the web server.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For further information on other fields, i would reference the sections on the RFC for HTTP1.1, as it is explained better, and it will also help you to get more into reading RFC's directly, and get familiar with their struture and how to make meaning out of them.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\",\n        children: \"Accept-Encoding\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4\",\n        children: \"Accept-Language\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://tools.ietf.org/html/rfc6265#section-4.2\",\n        children: \"Cookie\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In the next part of this post, we will look over the other side of HTTP, i.e., the Response. We will parse the first line of header field of our request, and will send a response back to the browser.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Until next time!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"meta":{"excerpt":"","slug":"understanding-the-http-protocol-part-1","title":"Understanding the HTTP Protocol in simple terms: Part 1","tags":["fundamentals","http","protocol"],"date":"Tue Feb 16 2016 05:30:00 GMT+0530 (India Standard Time)","author":"creativcoder","readingTime":"6min"}}},"__N_SSG":true}