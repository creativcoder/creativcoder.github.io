{"pageProps":{"post":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    em: \"em\",\n    a: \"a\",\n    code: \"code\",\n    pre: \"pre\",\n    span: \"span\",\n    blockquote: \"blockquote\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"If you are someone writing Rust wrappers for C libraries, then you might as well wanna verify that you are doing the right cleanups in your destructors or you might ignorantly create potential memory leaks from usage of your library. In this post we'll see how to use the very same tool you use in your C programs, i.e., \", _jsx(_components.em, {\n        children: \"Valgrind\"\n      }), \" to check for memory leaks in your wrapper library written in Rust.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In order to check for memory leaks we should first have code that does the leaking. Just to keep it brief we won't show a FFI library example, but we'll see a tiny example library exposing a method that does some allocation and forgets to release memory at the end of its scope (using \", _jsx(_components.a, {\n        href: \"https://doc.rust-lang.org/std/mem/fn.forget.html\",\n        children: \"mem-forget\"\n      }), \").\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So here's our small library called \", _jsx(_components.code, {\n        children: \"leaky_lib\"\n      }), \" with just one API called \", _jsx(_components.code, {\n        children: \"allocate()\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [\"[lib.rs]\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"use\"\n        }), \" std::mem;\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"pub\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"allocate\"\n        }), \"() {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"use\"\n        }), \" std::mem;\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\"\n        }), _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"bad_vec\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Vec\"\n        }), \"<\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"char\"\n        }), \"> = \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Vec\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"with_capacity\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1024\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"_\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"..\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1024\"\n        }), \" {\\n        bad_vec.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"push\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'0'\"\n        }), \");\\n    }\\n    mem::\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"forget\"\n        }), \"(bad_vec);\\n}\\n\\n[main.rs]\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"() {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"allocate\"\n        }), \"();\\n}\\n\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here, \", _jsx(_components.code, {\n        children: \"allocate()\"\n      }), \" allocates memory on the heap then we deliberately tell it to forget about that allocation thereby explicitely causing memory leak.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now if we run our program with \", _jsx(_components.code, {\n        children: \"valgrind --leak-check=full ./target/release/leaky_lib\"\n      })]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-bash\",\n        children: [\"creativcoder% valgrind --leak-check=full ./target/release/leaky_lib \\n==2488== Memcheck, a memory error detector\\n==2488== Copyright (C) 2002-2015, and GNU GPL\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'d, by Julian Seward et al.\\n==2488== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info\\n==2488== Command: ./target/release/leaky_lib\\n==2488== \\n==2488== \\n==2488== HEAP SUMMARY:\\n==2488==     in use at exit: 0 bytes in 0 blocks\\n==2488==   total heap usage: 6 allocs, 6 frees, 2,000 bytes allocated\\n==2488== \\n==2488== All heap blocks were freed -- no leaks are possible\\n==2488== \\n==2488== For counts of detected and suppressed errors, rerun with: -v\\n==2488== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\\n\\n\"\n        })]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To our surprise, the leak doesn't show up anywhere in valgrind logs. What is happening here :O ?\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The reason behind this is with the use of \", _jsx(_components.code, {\n        children: \"jemalloc\"\n      }), \" being used as the default allocator in \", _jsx(_components.code, {\n        children: \"rustc\"\n      }), \", which as of now doesn't play well with valgrind (See details on this \", _jsx(_components.a, {\n        href: \"https://github.com/rust-lang/rust/issues/28224\",\n        children: \"issue\"\n      }), \")\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"But fear not, Rust also allows us to fallback to OS's default allocator APIs i.e., the \", _jsx(_components.code, {\n        children: \"free\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"malloc\"\n      }), \". This can be opted in by using compiler attributes at your crate root (\", _jsx(_components.code, {\n        children: \"lib.rs\"\n      }), \") as shown below.\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"NOTE: Switching allocators only works for nightly release as of now. So just do a \", _jsx(_components.code, {\n          children: \"rustup override set nightly\"\n        }), \" to switch to nightly toolchain\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"#![feature(alloc_system)]\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"extern\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"crate\"\n        }), \" alloc_system;\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Once we have the above attribute in place, let's try running valgrind again.\\n(Some lines omitted for brevity)\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-bash\",\n        children: [\"creativcoder% valgrind --leak-check=full ./target/release/leaky_lib\\n==3198== Memcheck, a memory error detector\\n==3198== Copyright (C) 2002-2015, and GNU GPL\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'d, by Julian Seward et al.\\n==3198== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info\\n==3198== Command: ./target/release/leaky_lib\\n==3198== \\n==3198== \\n==3198== HEAP SUMMARY:\\n==3198==     in use at exit: 4,096 bytes in 1 blocks\\n==3198==   total heap usage: 15 allocs, 14 frees, 6,339 bytes allocated\\n==3198== \\n==3198== LEAK SUMMARY:\\n==3198==    definitely lost: 4,096 bytes in 1 blocks\\n==3198==    indirectly lost: 0 bytes in 0 blocks\\n==3198==      possibly lost: 0 bytes in 0 blocks\\n==3198==    still reachable: 0 bytes in 0 blocks\\n==3198==         suppressed: 0 bytes in 0 blocks\\n==3198== \\n==3198== For counts of detected and suppressed errors, rerun with: -v\\n==3198== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\\n\\n\"\n        })]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Aha! this time we can see our leaks...\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now let's quickly remove our explicit leaky intentions from the code. By that I mean removing the \", _jsx(_components.code, {\n        children: \"mem::forget(v)\"\n      }), \" and re-run this again.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-bash\",\n        children: [\"creativcoder% valgrind --leak-check=full ./target/release/leaky_lib\\n==3837== Memcheck, a memory error detector\\n==3837== Copyright (C) 2002-2015, and GNU GPL\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'d, by Julian Seward et al.\\n==3837== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info\\n==3837== Command: ./target/release/leaky_lib\\n==3837== \\n==3837== \\n==3837== HEAP SUMMARY:\\n==3837==     in use at exit: 0 bytes in 0 blocks\\n==3837==   total heap usage: 15 allocs, 15 frees, 6,339 bytes allocated\\n==3837== \\n==3837== All heap blocks were freed -- no leaks are possible\\n==3837== \\n==3837== For counts of detected and suppressed errors, rerun with: -v\\n==3837== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\\n\"\n        })]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Cool, no more memory leaks and we're saved.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Have a great day!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"meta":{"excerpt":"A quick guide on using Valgrind on Rust code","slug":"checking-memory-leaks-ffi","title":"Valgrind with Rust - Checking memory leaks in your ffi library","tags":["memory","profiling","rust","valgrind"],"date":"Mon Mar 13 2017 05:30:00 GMT+0530 (India Standard Time)","author":"creativcoder","readingTime":"4min"}}},"__N_SSG":true}