{"componentChunkName":"component---src-templates-page-js","path":"/minimax-intuition","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Building a minimax AI step by step","date":"13 May 2017","path":"/minimax-intuition","author":null,"excerpt":null,"tags":["search","tictactoe","game","ai","minimax","game","python"],"coverImage":null},"id":"e1e4f0a9-a817-55bf-901f-129db6256c41","html":"<p>This post is an attempt to explain the minimax algorithm that can be used to simulate an AI for zero-sum games like tic tac toe, chess, checkers etc. These games are also called games of perfect information.</p>\n<p>This post also guides readers with a concise implementation step by step in Python. We'll implement the simplest form of minimax to help beginners get started so expect the implementation to involve no optimization. I may do a follow up post where we enhance our AI to not perform redundant state evaluation by pruning the game tree using <a href=\"https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning\">alpha beta</a> parameters. The code is available on my <a href=\"https://github.com/creativcoder/minimax\">github</a>.</p>\n<p>First, let's get familiar with some background and jargons.</p>\n<p>The origin of the minimax algorithm is from a field called Game Theory where this algorithm is applied to games of perfect information. A tic tac toe game is one of simplest example of a game with perfect information. A game of perfect information will be transparent for both players in terms of its moves and there is no element of suprise as to what moves other player ends up making as in games such as poker. Every board piece or move is apprehensible by both players.</p>\n<hr>\n<p>In order for our computer program to analyze the game of tic tac toe and make intelligent moves, we need to give the computer a representation by which it can analyze the game. By analysing i mean it must be able to check whether there is a win/lose situation or how many empty slots are left in the game grid or how to make moves so that other player does get chance to make winning moves.</p>\n<p>To help ourselves and the computer with the representation, we will build certain concepts and abstrations about our game in order to implement our AI. Let get to them one by one. It is also where we start implementing the tic tac toe in code.</p>\n<p><strong>Initial Game State</strong> - Its when we start our game with 9 empty cells. This will be our initial game state. In general a <code class=\"language-text\">State</code> in AI parlance is a collection of information that precisely describes the situation of an entity in its environment. In our case its just an array of cells each having a (\"-\") i.e., an empty slot.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Tictactoe</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>board <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'-'</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p><strong>Game Loop</strong>: We need a looping mechanism of some sort, so that we can keep asking the human player for his next move until he wins (which he may never with our AI ðŸ‘½) or the AI wins or its a draw.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    def start_game(self):\n        while True:\n            # do stuff</code></pre></div>\n<p><strong>Players</strong>: Of course we need players. Player one is the human and other will be the computer. We add a boolean <strong><code class=\"language-text\">won</code></strong> to help break out of our game loop when any of the two player wins.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Tictactoe(object):\n    def __init__(self):\n        self.board = [&#39;-&#39; for i in range(0,9)]\n        self.player_one = None\n        self.player_two = None\n        self.won = False</code></pre></div>\n<p><strong>Game State</strong>: It is the board configuration that we have at any point of time during the game.\nFor example, the board state</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">| - | O | - |\n| - | X | X |\n| - | - | - |</code></pre></div>\n<p>can be considered as some intermediary game state during the course of gameplay.</p>\n<p><strong>Game Tree</strong> - From a given game state S, it is a tree with S as its root and its children consisting of all next states the game can go if we play all the remaining empty cells one by one. An example will make this clear:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">| - | O | - |\n| X | X | - |\n| O | O | X | </code></pre></div>\n<p>From this state, all possible next game states can be (suppose the player who plays these moves is X):</p>\n<p>1)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">|{X}| O | - |\n| X | X | - |\n| O | O | X |</code></pre></div>\n<p>2)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">| - | O |{X}|\n| X | X | - |\n| O | O | X |</code></pre></div>\n<ol start=\"3\">\n<li>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">| - | O | - |\n| X | X |{X}|\n| O | O | X |</code></pre></div>\n</li>\n</ol>\n<p>These our the only <strong>next</strong> states that we can get from our state S when its player X's turn. It it these states that we will need to generate in our minimax algorithm</p>\n<p>Now, we're getting close. Lets build helper utilities to check whether someone won the game or not. Each of them takes our game board as the only parameter.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def won(board):\n    # Horizontal Check\n    for i in range(0,9,3):\n        if board[i:i+3].count(board[i]) == 3 and board[i] != &#39;-&#39;:\n            return board[i]\n    # Vertical Check\n    for i in range(0,3):\n        if board[i] == board[i+3] == board[i+6] and board[i] != &#39;-&#39;:\n            return board[i]\n    # Diagonal Check\n    mid = board[4]\n    if board[0] == mid == board[8] and mid != &#39;-&#39;:\n        return mid\n    elif board[2] == mid == board[6] and mid != &#39;-&#39;:\n        return mid</code></pre></div>\n<p>Lets also make a function to get indices of empty slots in our game which comes handy in our minimax function:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def empty_slots(board):\n    return [idx for i in range(len(board)) if board[i] == &#39;-&#39;]</code></pre></div>\n<p>We need to check whether the game is a draw, so lets also add that method:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def is_draw(board):\n    for i in board:\n        if i == &#39;-&#39;\n        return False\n    return True</code></pre></div>\n<p>There are other other few ideas that needs to be mentioned before we turn towards minimax.</p>\n<ul>\n<li>Utility score: Its a property on every game state by which we can know whether the game state favours the player or not. In a game state where X wins (the human player) it will have a score of +1, but will be -1 in case O (the computer) wins. In our game of tic tac toe, the number can be any any value, but in games such as chess, the pieces will influence the score depending on whether its a pawn or a rook as they differ in value.</li>\n<li>Utility goal: The utility goal can either be to maximize the utility score or to minimize the utility score. This is the third parameter passed to minimax and is just a <code class=\"language-text\">bool</code> in simplest case. When minimax is invoked the first time, this is passed as false meaning that the computer wants to minimize the human player's score.</li>\n<li>Ply - Every level of child game states in the game tree is called a Ply.</li>\n</ul>\n<h3>The Minimax algorithm overview</h3>\n<hr>\n<p>The higher level idea behind the AI is that when it is computer's turn, we will invoke a procedure called <code class=\"language-text\">minimax</code>, which looks at the current tic tac toe board, generates the <strong>next game states</strong> and tries to play the whole game from the current board state until it reaches a end state (which can be a win/lose or a draw state) and then decides which move is good based on the end game state. The minimax algorithm plays the role of both players. One being the <strong>max</strong>imizer (say X) and other other <strong>mini</strong>imizer (say Y). The maximizer plays the game to maximize his score, while the minimizer plays to minimize the score of the maximizer. The algorithm is a recursive one and flips between the minimizer and maximizer at every layer of game state traversal. <img src=\"http://i.imgur.com/ileTCMW.jpg\" alt=\"alt tree\"></p>\n<h3>The Minimax algorithm in detail</h3>\n<hr>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def minimax(board, player, maximizing):\n    # cool stuff ahead</code></pre></div>\n<p>The algorithm needs three information i.e., the board, the player who is playing and whether he plays for maximizing his score or the contrary. The algorithm proceeds by walking the game tree generated from the given game state in depth first search.</p>\n<p> Then It does the same thing (i.e., calls itself) on the played children states, until it reaches a leaf node that has all slots filled. As its a recursive algorithm so lets define our bases cases here. Since the algorithm walks and explore game states. There must be some end game state after which no more moves are possible. And these game states are the tree's leaf nodes. They can be in any one of the three states</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Human wins\nComputer wins\nA tie</code></pre></div>\n<p>Only leaf nodes in our game tree have some assoicated values with them which we call the utility of the nodes.</p>\n<p><strong>Utility function</strong> - Its a criteria by which a particular game state can be distinguished to provide benefit towards winning.</p>\n<p>So accordingly we assign certain scores to each of the leaf states.\n* Human wins - +1 (these will flip in sign as our minimax takes turns)\n* Computer wins -1\n* A tie 0</p>\n<p>Minimax will actually use these leaf scores to figure out scores for the intermediate game states. Taking the scores from the leaf nodes make sense because, the path from root to leaf, is what leads us to that score, so the intermediate node also can assume the same score as of leaf, and bubble up that value to root to indicate that is move is beneficial for the player.</p>\n<p>Now when minimax actually tries to </p>\n<ul>\n<li>We start the game by creating an instance of <code class=\"language-text\">Tictactoe</code> and then creating player variables from user input</li>\n<li><code class=\"language-text\">start_game()</code> starts the game loop.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">if</span> __name__<span class=\"token operator\">==</span><span class=\"token string\">'__main__'</span><span class=\"token punctuation\">:</span>\n    tic <span class=\"token operator\">=</span> Tictactoe<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    tic<span class=\"token punctuation\">.</span>init<span class=\"token punctuation\">(</span><span class=\"token builtin\">str</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Enter player choice X or O'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    tic<span class=\"token punctuation\">.</span>start_game<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>You can test the game by running in console, and check if you are able to win against the AI (most probably not). So that was it. I hope this gave enough insight on how minimax works under the hood. I encourage readers to extend this code to introduce difficulty levels in the game, where on easy levels the AI may make some mistakes in making the move and try optimize the search using a technique called alpha beta pruning. Thanks. Discuss on Reddit !</p>","excerpt":"This post is an attempt to explain the minimax algorithm that can be used to simulate an AI for zero-sum games like tic tac toe, chessâ€¦"}},"pageContext":{"type":"posts","next":{"frontmatter":{"path":"/learn-rust-2017","title":"Helping new Rustacians in 2017","tags":["open source","mozilla","rust"]},"fileAbsolutePath":"/home/rahul/opensource/creativcoder.dev/src/posts/learn-rust-2017.md"},"previous":{"frontmatter":{"path":"/rust-community-bangalore","title":"Meet rustox! Rust community at Bangalore","tags":["community","rustox","rust","meetup","2017"]},"fileAbsolutePath":"/home/rahul/opensource/creativcoder.dev/src/posts/rust-community-bangalore.md"}}}}