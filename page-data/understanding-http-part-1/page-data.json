{"componentChunkName":"component---src-templates-page-js","path":"/understanding-http-part-1","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Understanding the HTTP Protocol in simple terms part 1","date":"16 February 2016","path":"/understanding-http-part-1","author":"creativcoder","excerpt":null,"tags":null,"coverImage":null},"id":"c05e26e2-1d63-5c5b-b688-f42bd21dd716","html":"<p>I have seen many of my peers ask from time to time, what is http, and how it works.\nAlso as a web developer understanding HTTP protocol is an essential asset to be able to think in a way, as to how to architecture your web apps, so that it follows the semantics of HTTP.</p>\n<p>This post will discuss on the abstraction/medium on which the 'user facing' internet stands on.</p>\n<p>A bit of background first!</p>\n<p>Just as we humans need a language with a meaningful structure to communicate and exchange ideas effectively among our peers; computers in a similar way need to talk to different computers over a network. And being dumb machines, they need every detail communicated in the message in a precise manner. They need a medium or a language to speak, so that exchange of resources can take place between them. And HTTP is just that language or a protocol in technical parlance, using which computers can talk to other remote computers over a network.\nTechnically speaking, HTTP is a request/response based, stateless (will come to this on a follow up post) application layer protocol, implemented on top of a stateful protcol which is TCP/IP usually. TCP/IP is another lower layer of abstraction for communication over the network.</p>\n<p>And in a similar way like, our english sentences have a formal structure and semantic; the HTTP protocol also has a formal description of it, usually defined in a spec sheet, called <a href=\"https://www.ietf.org/rfc.html\">RFC</a>'s (Request for Comments). These are standardized documents, that are accepted globally and maintained by IETF(Internet Engineering Task Force).</p>\n<p>The HTTP's <a href=\"https://www.rfc-editor.org/rfc/rfc2616.txt\">RFC</a> describes in details, every aspect of the request reponse cycle, that can happen over when two machines are communicating over HTTP, how the message will be parsed, what sort of security aspects to employ when sending the message, etc., and these are then implemented by servers and clients ( usually web browsers ), using a programming language based on the infrastructure and needs. The choice of language, is independent, as HTTP specification is language agnostic.</p>\n<p>So a server that, is able to speak the http protocol is called an HTTP Server.</p>\n<p>Examples of http servers are <a href=\"https://www.nginx.com\">nginx</a>, <a href=\"http://www.apache.org\">apache</a>, etc.</p>\n<p>and similarly, a client which is able to speak the http protcol, is called an Http Client.</p>\n<p>Examples of http clients are <a href=\"https://curl.haxx.se/\">cURL</a> (command line http client), python <a href=\"https://pypi.python.org/pypi/requests\">requests</a> library and ofcourse web browsers.</p>\n<p>Now with that explained, we are at the point to see some actual HTTP message.</p>\n<p>In HTTP, there are two parts of communication.\nOne is the request part, which is sent by http-clients, and the other is the response part, which is sent back by the servers on getting a http request.</p>\n<p>Now before we see any actual message, let us understand what a resource means in http.\nUnder HTTP, anything that we want to communicate to and fro or query for, with the remote machine is generally termed as a Resource.</p>\n<p>So lets see how, how do you say 'hi' in http. (the request part of HTTP Communication)</p>\n<p>Before that, lets fire up a socket server in python over TCP, so that we can see what, http request mesage we are receiving from our browser(an http client). We will expand our server further to respond to our browser with a 'hey hi client', when the request is <code class=\"language-text\">/hi</code> in part 2 of this post.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> socket\n\nhost<span class=\"token punctuation\">,</span>port <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">,</span><span class=\"token number\">1313</span><span class=\"token punctuation\">)</span>\n\nlistener <span class=\"token operator\">=</span> socket<span class=\"token punctuation\">.</span>socket<span class=\"token punctuation\">(</span>socket<span class=\"token punctuation\">.</span>AF_INET<span class=\"token punctuation\">,</span>socket<span class=\"token punctuation\">.</span>SOCK_STREAM<span class=\"token punctuation\">)</span>\nlistener<span class=\"token punctuation\">.</span>setsockopt<span class=\"token punctuation\">(</span>socket<span class=\"token punctuation\">.</span>SOL_SOCKET<span class=\"token punctuation\">,</span>socket<span class=\"token punctuation\">.</span>SO_REUSEADDR<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\nlistener<span class=\"token punctuation\">.</span>bind<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>host<span class=\"token punctuation\">,</span>port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nlistener<span class=\"token punctuation\">.</span>listen<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Serving on port {}\"</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">format</span><span class=\"token punctuation\">(</span>port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">while</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span>\n    client_conn<span class=\"token punctuation\">,</span>client_addr <span class=\"token operator\">=</span> listener<span class=\"token punctuation\">.</span>accept<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    request <span class=\"token operator\">=</span> client_conn<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span> request </code></pre></div>\n<p>We won't be diving much into the details of the python sockets connection mechanism, to keep the blog focused only on HTTP. I intend to do another blog post on sockets. To put it in brief, sockets are endpoints of communcation, or channels,(technically its a tuple of (ip_address,port) ) that forms a pathway for messages to be sent accross remote entities.</p>\n<p>Save it as server.py, and do <code class=\"language-text\">python server.py</code> to make it, start listening for requests on port 1313.</p>\n<p>Now head over to the web browser, and put the url : <code class=\"language-text\">localhost:1313/hi</code>.</p>\n<p>Over your terminal window you will see something getting logged to standard output like this.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">GET /hi HTTP/1.1\nHost: localhost:1313\nConnection: keep-alive\nAccept: text/html, application/xhtml, application/xml .... (omitted for brevity)\nUser-Agent: Mozilla/5.0 (Windows NT 6.3) .... (omitted for brevity)\nAccept-Encoding: gzip, deflate,sdch\nAccept-Language: en-US,en;q=0.8\nCookie: _ga=GA1.1.52864490.1449694093;__atuvc=27%7C7 ....</code></pre></div>\n<p>An http request starts a series of key value pairs, which in http parlance are known as <code class=\"language-text\">header fields</code>.Basically each key value pair stores a metadata about our request, which is important to let the server know, like information about which http client it will be talking to and what resource is the client asking for and other details. I will touch on a few header fields here.</p>\n<p>The first line is of our concern here:</p>\n<p><code class=\"language-text\">GET /hi HTTP/1.1</code></p>\n<p>This says that, it is a <code class=\"language-text\">GET</code> request, and the path to our resource resides at <code class=\"language-text\">/hi</code>, and next is the protcol that the client speaks which is <code class=\"language-text\">HTTP/1.1</code>.</p>\n<p>The next line tells about, the <code class=\"language-text\">host</code>, which is <code class=\"language-text\">localhost:1313</code>. It serves as the information to the server, where to send the resposne back to. <code class=\"language-text\">localhost</code> is our domain,<code class=\"language-text\">1313</code>, is our port number on which the server is listening to.</p>\n<p>Note: Now web servers by convention, listen on port 80</p>\n<p>Now before we talk about the next line, we need to know about the term <code class=\"language-text\">stateless</code>. As HTTP is a stateless protocol, each request and response cycle is not dependent on any previous request reponse. Every response that is made, is ignorant of the state of the server, or any previous request that was sent. I intend to have another blog post on stateless property of HTTP, so for the time being lets, keep it to this definition.</p>\n<p>So the <code class=\"language-text\">Connection: keep-alive</code> says, that we want to reuse the same tcp connection we established on the request, for further requests. As HTTP is stateless it closes the connection after every request it makes and so for every subsequent request, HTTP has to re-establish connection to the server.\nIf this header field is present, this will try to minimize the the overhead of re-establising the tcp connection on further request. The time for connection keep alive, is usually specified when implementing the server, and also can be configured.</p>\n<p>The <code class=\"language-text\">User-Agent</code> header serves as another identity mechanism, to send different, representations of response message to the user. In this example, the user-agent is a Web browser. A mobile device will send a user agent ( for example <code class=\"language-text\">Apple-iPhone4C1/902.206</code> is the user agent for an Apple iPhone4C ); that is different from a web browser becuase its different in terms of form factor, and various features. So accordingly that wil be served differently by the web server.</p>\n<p>For further information on other fields, i would reference the sections on the RFC for HTTP1.1, as it is explained better, and it will also help you to get more into reading RFC's directly, and get familiar with their struture and how to make meaning out of them.</p>\n<p><a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\">Accept-Encoding</a></p>\n<p><a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4\">Accept-Language</a></p>\n<p><a href=\"https://tools.ietf.org/html/rfc6265#section-4.2\">Cookie</a></p>\n<p>In the next part of this post, we will look over the other side of HTTP, i.e., the Response. We will parse the first line of header field of our request, and will send a response back to the browser.</p>\n<p>Thanks. Let me know what you feel of this post.</p>","excerpt":"I have seen many of my peers ask from time to time, what is http, and how it works.\nAlso as a web developer understanding HTTP protocol is…"}},"pageContext":{"type":"posts","next":null,"previous":{"frontmatter":{"path":"/trait-objects-in-rust","title":"Using Trait objects in Rust","tags":["rust","trait objects","dispatch"]},"fileAbsolutePath":"/home/creativcoder/opensource/creativcoder.dev/src/posts/trait-objects-rust.md"}}}}