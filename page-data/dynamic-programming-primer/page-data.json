{"componentChunkName":"component---src-templates-page-js","path":"/dynamic-programming-primer","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Dynamic programming primer","date":"03 January 2017","path":"/dynamic-programming-primer","author":"creativcoder","excerpt":"An intuitive guide on the basics","tags":["algorithms","optimization","beginner","dynamic-programming"],"coverImage":null},"id":"1a27067a-fbfb-5b49-8dc0-8d8f456874a2","html":"<blockquote>\n<p><em>\"A complex entity is a combinatoric amalgamation of simple loosely coupled pieces\"</em></p>\n</blockquote>\n<p><img src=\"http://i.imgur.com/IaiXuwh.jpg\"></p>\n<p>Dynamic programming (DP for brevity) while being widely applicable to a lot of computer science problems is often talked about being complicated to understand and so this post tries to uncover the very basic ideas behind them. This article is aimed for the beginner so experienced readers may not find it useful though I would love suggestions and improvements from experienced people.</p>\n<p>I'll try to introduce readers who are new to DP technique of problem solving starting with a very trivial example. DP gives you the ability think problems bottom up rather than more natural and intuitive top down thinking that most of us use. Let me tell you that the bottom up thinking approach won't come readily from just solving one or two problems, you really have to practice a lot of problems of this kind to wire it properly to your thinking and even prior to solving problems using DP we should know one thing that not all problems exhibit a DP based solution the reasons for which you discover you read below.</p>\n<p>I myself was a bit vague on the principles of dynamic programming but with dedicated readings from the last few months i have been able to make sense of DP and this blog post is a step towards consolidating my understanding.</p>\n<p>So with that intro aside, let's dive in. Let me describe the essense of Dynamic Programming!</p>\n<p>Many articles starts explaining dynamic programming by introducing the fibonacci sequence to the readers. We will eventually get there but before that I want to explore a more trivial example to really see the nature of problems that we encounter everyday and how it closely resembles the thinking behind dynamic programming.</p>\n<p>Dynamic programming can be seen in integer sequences as well. (From the perspective of an experienced DP guy, this is not a very convincing example as it does not have overlapping subproblems, but I wanted a more trivial example.)</p>\n<p>Consider the problme of generating non-negative integer sequences.</p>\n<p>Let us ask ourselves how can we form the number 7?\nAlthough there are more than one possible answer to this. Lets take one solution to it:\n7 = 6 + 1.</p>\n<p>So you see 7 can be formed by taking the previous number 6 and adding 1 to it. Similary you can intuit that 6 can be formed by using 5 and adding 1 to it and so on.</p>\n<p>In this case, the problem of making the number 7 is split into two subproblems:</p>\n<ul>\n<li>Making 6</li>\n<li>Adding 1 to it</li>\n</ul>\n<p>This brings us to the concept of a subproblem. </p>\n<p><strong>Subproblem</strong> - A subproblem S(n) is a self contained solution state towards a larger problem. In the above trivial example on integers, the subproblem for getting the number 7 is: (Problem of getting the number 6) + 1. Similarly, Problem of getting the number 6: (Problem of getting number 5) + 1.</p>\n<p>To generalize for the above problem, n can be solved by solving (n-1) and adding 1 to it. But in DP, we approach it from the opposite side. To get to the solution 7, we start with a base case solution S(0) =  0 (well zero can be constructed by having only 1 zero), then we construct the next solution to the subproblem S(1) = S[0] + 1. Then S(2) = S[1] + 1, then S(3) = S[2] + 1 until we reach S(7) = S[6] + 1. Notice the square brackets when we are building the next solution. It means that we are using the previous solution which was already calculated before.</p>\n<p>Having made the concept of a subproblem clear, let's get to our fibonacci example which most of you should be familiar with. Here's a formal definition:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">f(n) = f(n-1) + f(n-2)        where n[0] = 0 and n[1] = 1</code></pre></div>\n<p>Lets map the concepts we learned from our previous example.</p>\n<p>Here <code class=\"language-text\">n[0]</code> and <code class=\"language-text\">n[1]</code> are base cases. <code class=\"language-text\">f(n)</code> is the instance of the problem we are trying to solve and by its definition <code class=\"language-text\">f(n-1)</code> and <code class=\"language-text\">f(n-2)</code> are the subproblems which when added gives the solution to f(n).</p>\n<p>There is a straight forward recursive approach, to solve fibonacci sequences.</p>\n<p>A python example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def fib(n):\n  if n == 0 or n == 1:\n    return n\n  return fib(n-1)+fib(n-2)</code></pre></div>\n<p>If we explicitely list out the solution to f(7):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">f(7) = f(6) + f(5)\n  (A)    (B)</code></pre></div>\n<p>Lets also expand A and B</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">A: f(6) = f(5) + f(4)\nB: f(5) = f(4) + f(3)</code></pre></div>\n<p>Now there's an interesting observation branching of the problem into two subproblems. We are recalcuting at least one thing in the next subproblem that we already calculated in previous levels. An example of this would be : <code class=\"language-text\">f(5)</code> is calculated in <code class=\"language-text\">f(7)</code> branching, but it's also calculated in <code class=\"language-text\">f(6)</code> branching. This redundant recalculation continues at all levels of branches, resulting in a worst case complexity of <code class=\"language-text\">2^n</code>. As a result, this solution takes a lot of time to run for queries such as <code class=\"language-text\">f(40)</code> or <code class=\"language-text\">f(100)</code>.</p>\n<p>This fibonacci problem shows us two attributes which are characteristics for knowing if a DP solution can be applied to a problem:</p>\n<ol>\n<li><strong>Overlapping subproblems</strong> - As explained above on the branching of function calls, we are re-calculating many things that have been calculated before. The fibonacci example shows that there are same subproblems that are overlapping or recalculated at many levels.</li>\n<li><strong>Optimal substructure</strong> - This simply means that, optimal solutions to smaller sub problems gives the solution to the larger problem. The fibonacci example does help in depicting this, but this can be seen in algorithms such as the Shortest Path Problem, where we must need a shortest path for the subproblems to get the overall shortest path.</li>\n</ol>\n<p>So the problem of finding Fibonacci numbers can indeed be solved using DP.</p>\n<p>But it can be done in two ways:</p>\n<ul>\n<li>Top down</li>\n<li>Bottom up</li>\n</ul>\n<p>Let's take a look at the top down approach, also know as memoization.</p>\n<blockquote>\n<p>The term \"memoization\" was introduced by Donald Michie in the year 1968. It's based on the Latin word memorandum which means \"to be remembered\".</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">cache <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">fibonacci_memo</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> n <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\n        cache<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> n\n        <span class=\"token keyword\">return</span> n\n    <span class=\"token keyword\">elif</span> n <span class=\"token keyword\">not</span> <span class=\"token keyword\">in</span> cache<span class=\"token punctuation\">:</span>\n        cache<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> fibonacci_memo<span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> fibonacci_memo<span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> cache<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>So what did we just do? We just added a <code class=\"language-text\">cache</code> dictionary to store the computed values. Then for the given query <code class=\"language-text\">n</code>, our cache method will return results from our cache rather than re-computing it, If it does not exist</p>\n<p>And here's our bottom up approach:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">cache <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">fibonacci_dp</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  <span class=\"token keyword\">if</span> n <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\n    cache<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> n\n    <span class=\"token keyword\">return</span> n\n  <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n      cache<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> cache<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span>c ache<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">return</span> cache<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>In the bottom up approach, we construct our solution optimally from the base cases and work our way up until we reach to the given <code class=\"language-text\">n</code>. This approach cuts down our overhead of making function calls and creating new stack frames.</p>\n<p>So to summerize our understanding, Dynamic programming is:</p>\n<ol>\n<li>Splitting our problem into subproblem and identifying if the subproblems are overlapping.</li>\n<li>Solving the sub problems optimally and saving it and try it on a larger problem to see if we are getting the desired solution to the larger problem.</li>\n</ol>\n<p>DP is not some definite algorithm, but consider it as a meta algorithm that allows you to minimize the runtime complexity of your existing algorithm that you have thought of by identifying and eliminating redundant parts of it.</p>\n<p><em>Richard Bellman</em> who theorized DP in his paper describes it as a decision guiding principle in a problem where we have several states of a problem and we wish to maximize the outcome of the problem. It is an algorithm optimization technique.</p>\n<p>If you want to dive deeper into the roots of it, consider reading this paper <strong><a href=\"http://smo.sogang.ac.kr/doc/bellman.pdf\">http://smo.sogang.ac.kr/doc/bellman.pdf</a></strong> by Richard.</p>\n<p>So that was basically it about dynamic programming. In the next post on this topic, we will see another DP problem by introducing the coin change problem.</p>\n<p>Cheers :)</p>","excerpt":"\"A complex entity is a combinatoric amalgamation of simple loosely coupled pieces\"  Dynamic programming (DP for brevity) while being widelyâ€¦"}},"pageContext":{"type":"posts","next":{"frontmatter":{"path":"/service-workers-servo","title":"Basic Service Worker support lands in Servo","tags":["servo","rust","open-source","gsoc"]},"fileAbsolutePath":"/home/creativcoder/opensource/creativcoder.dev/src/posts/service-workers-servo.md"},"previous":{"frontmatter":{"path":"/learn-rust-2017","title":"Helping new Rustacians in 2017","tags":["open source","mozilla","rust"]},"fileAbsolutePath":"/home/creativcoder/opensource/creativcoder.dev/src/posts/learn-rust-2017.md"}}}}