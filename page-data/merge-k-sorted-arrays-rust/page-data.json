{"componentChunkName":"component---src-templates-page-js","path":"/merge-k-sorted-arrays-rust","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Merge k sorted arrays in Rust","date":"07 December 2020","path":"/merge-k-sorted-arrays-rust","author":null,"excerpt":"An explanation and implementation blog post in Rust","tags":["algorithms","databases","merge","key-value"],"coverImage":null},"id":"558613c1-9cc8-5c1a-becb-2652b59d4d95","html":"<p>The other day, I was reading about LSM Tree based database storage engines (specifically, the LevelDB <a href=\"https://github.com/google/leveldb/blob/master/doc/impl.md\">docs</a>) where I came to know about a phase called compaction. LSM Tree based database storage engines are key-value storage systems where every operation is append only to favour less <a href=\"https://en.wikipedia.org/wiki/Write_amplification\">write amplification</a> and to reduce latency. LevelDB persists data file segments to disk (when the in-memory table hits a threshold) in sorted order to support efficient read queries. Even operations such as deletes or updates appends new entries to the underlying storage and this often leads to keys that are obsolete but still remain on disk and that increases disk usage. To overcome this, they often use a phase called <em>compaction</em> where several sorted files are merged into single file to remove old data records in background. In order to implement a similar compaction strategy in my toy database project, I used the <code class=\"language-text\">merge</code> sub-routine from merge sort, generalizing it to k sorted arrays. In this post, I write about the implementation the merge k algorithm in Rust. If you know the merge sub-routine from merge sort, you should feel right at home understanding the algorithm.</p>\n<h2>The problem</h2>\n<p>Before formalizing the solution, we'll re-state the problem again with examples and reason up from there to come up with an implementation in Rust.</p>\n<p>We are given <code class=\"language-text\">k</code> array of items that are sorted. The problem is to implement a function that given <code class=\"language-text\">k</code> sorted arrays, merges them and returns an array where all the elements are in sorted order.</p>\n<p>For example, If we are given 2 sorted arrays:</p>\n<p><code class=\"language-text\">a = [3, 5]</code></p>\n<p><code class=\"language-text\">b = [2, 7]</code> where <code class=\"language-text\">k = 2</code></p>\n<p>Then the merged array we get, would be <code class=\"language-text\">c = [2, 3, 5, 7]</code></p>\n<h2>Obvious naive solution</h2>\n<p>It's always a good idea to start with what you already know as the thinking lends itself to revealing more about the problem at hand. So, the obvious approach to solve this would be to just concatenate the two arrays and sort them. Here's a solution in Rust:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token function\">vec!</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> <span class=\"token function\">vec!</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> c <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    a<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dbg!</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>That was quite easy, but it does have a <code class=\"language-text\">O(n*k * log n*k)</code> worst case time complexity, where <code class=\"language-text\">n</code> is the size of the resulting vector and <code class=\"language-text\">k</code> is the number of arrays. Can we do better?</p>\n<p>Let's try a different approach. Without thinking about the implementation, how would you normally put these elements in order by hand? Let's distill down the above example and give it a thought with a case by case analysis. </p>\n<h4>Case 1:</h4>\n<p>Let's say for example, the arrays have only 1 element in them:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\">a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\nb <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>In this case, it's pretty trivial. We just compare the first item with the second and take the smallest of the two, and insert it as first element in the resulting array: <code class=\"language-text\">[2]</code>. What remains is <code class=\"language-text\">3</code> from <code class=\"language-text\">a</code> which we then append giving us <code class=\"language-text\">[2, 3]</code> as the merged sequence.</p>\n<h4>Case 2:</h4>\n<p>Now, let's consider if one of the arrays have more than one element:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\">a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\nb <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>In this case, we'll start again with the first item in both arrays and pick the smallest of the two items which is <code class=\"language-text\">2</code>. The next item to compare is <code class=\"language-text\">3</code> (from <code class=\"language-text\">a</code>) and <code class=\"language-text\">5</code> (from <code class=\"language-text\">b</code>), among which <code class=\"language-text\">3</code> is chosen as the next smallest element. At this point in time, we have exhausted all items in array <code class=\"language-text\">a</code>. Now, whatever remains to be put in the merged array has to be from array <code class=\"language-text\">b</code>. This is because of the invariant that we always pick the smallest item in each iteration so if all items from array <code class=\"language-text\">a</code> are exhausted, all remaining elements must be greater than last element in <code class=\"language-text\">a</code>. So we append <code class=\"language-text\">5</code> from <code class=\"language-text\">b</code> to our merged array to give us: <code class=\"language-text\">[2, 3, 5]</code>.</p>\n<p>From the dry run of the above two cases, you must have already thought of using two variables as indexes over the arrays and walk over them one by one, taking the next smallest element in each iteration until one of them exhausts, and then copy all the items from the remaining array to our merged sequence. Sounds simple? Let's implement that:</p>\n<h2>Implementation of merge k, where k = 2</h2>\n<p>To simplify the implementation for readability, we'll limit the items to integer (<code class=\"language-text\">i32</code>) values. Once we have the implementation in place, one can refactor it easily to make it generic over any <code class=\"language-text\">T</code>.</p>\n<p>Here's how we can implement the above index pointer based solution in Rust:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">[</span>i32<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">[</span>i32<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> Vec<span class=\"token operator\">&lt;</span>i32<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">mut</span> i<span class=\"token punctuation\">,</span> <span class=\"token keyword\">mut</span> j<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> sorted <span class=\"token operator\">=</span> <span class=\"token function\">vec!</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> remaining<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> remaining_idx<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">loop</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n            sorted<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            i <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> i <span class=\"token operator\">==</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>remaining <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span> remaining_idx <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            sorted<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            j <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> j <span class=\"token operator\">==</span> b<span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>remaining <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span> remaining_idx <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> remaining_idx<span class=\"token punctuation\">..</span>remaining<span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        sorted<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>remaining<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    sorted\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We have the <code class=\"language-text\">merge</code> function defined that takes in two slices of integers aka reference to an array of integers and returns a <code class=\"language-text\">Vec&lt;i32&gt;</code> (a heap allocated value). Within <code class=\"language-text\">merge</code>, we create two indexes <code class=\"language-text\">i, j</code> that start with <code class=\"language-text\">0</code>. We also create a <code class=\"language-text\">remaining</code> and <code class=\"language-text\">remaining_idx</code> to point to the array that gets left after all items from the other array gets exhausted. Next, we run a <code class=\"language-text\">loop {}</code>, where we pick the smallest item, push it to <code class=\"language-text\">sorted</code> and increment the respective index. We also do an additional check if we reach the end on one of the arrays and assign <code class=\"language-text\">remaining</code> and <code class=\"language-text\">remaining_idx</code> accordingly. After the loop, we loop over the <code class=\"language-text\">remaining</code> array items and push to <code class=\"language-text\">sorted</code>.</p>\n<p>But, the above solution works only for 2 arrays. We need to generalize the solution to k sorted arrays.</p>\n<h2>Generalizing to k sorted arrays</h2>\n<p>How would one extend the above solution to k sorted collection of items?</p>\n<p>Well it turns out that now we need to keep k pointers to k arrays and pick the smallest item out of k. It's easy enough to write code to keep track of the pointers, if we have let's say &#x3C; 10 or &#x3C; 100 arrays to be merged. Or instead of keeping pointers, we could store an array of indexes into the arrays. That's another solution that works again for smaller values of k. But, it's not a convenient or maintainable code to write when we have very large arrays to be merged. Moreover, the number of comparision increases linearly as k increases.</p>\n<p>Following along the same solution, let's think about what we need to find from the k arrays at the first iteration of the loop. That's right, we need to find the minimum from k items. This might give you a hint of using some data structure that supports getting minimum item from the <code class=\"language-text\">k</code> items. One data structure that comes to my mind is the heap data structure. In particular, a min-heap data structure.</p>\n<h2>Enter the min heap</h2>\n<p>A Heap is a complete binary tree (nodes are inserted breadth first left to right) where there's a relation between parent and child nodes. This is the heap property. There are two variants of heap: min heap and max heap. In min heap the every parent node is smaller than the child and conversely for the max heap. At minimum, any implementation supports three key APIs:</p>\n<ol>\n<li>inserting - Adds an element to the heap</li>\n<li>removing - Removes an element to the heap</li>\n<li>heapify - rebalances the tree while maintaining the heap property.</li>\n</ol>\n<p>At all times the heap property must be maintained when inserting or removing items from the heap. Internally the heap uses the <code class=\"language-text\">siftDown</code> and <code class=\"language-text\">bubbleUp</code> sub-routines to maintain the heap property.</p>\n<p>So using a min-heap, we can insert the first k items into the array. Then we keep popping until our heap is empty and keeping the array indexes.</p>\n<p>To implement this, we need to modify our solution a bit.</p>\n<p>Our <code class=\"language-text\">merge</code> method now takes in a <code class=\"language-text\">Vec&lt;Vec&lt;i32&gt;&gt;</code> as a parameter (an array of array of signed integers):</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>arrays<span class=\"token punctuation\">:</span> Vec<span class=\"token operator\">&lt;</span>Vec<span class=\"token operator\">&lt;</span>i32<span class=\"token operator\">>></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Next, let's create an <code class=\"language-text\">Item</code> struct that will hold references to the k arrays and their respective index as their iteration state. The index will tell us where in our array we are currently at. This <code class=\"language-text\">Item</code> instance will be the element that goes in our min heap. </p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[derive(Debug, Eq)]</span>\n<span class=\"token keyword\">struct</span> Item<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    arr<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'a</span> Vec<span class=\"token operator\">&lt;</span>i32<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n    idx<span class=\"token punctuation\">:</span> usize\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Now <code class=\"language-text\">Item</code> doesn't convey how they should be compared, as it's a new data type we've defined. So we need to tell the type system how they should be compared. Doing this is easy and we'll just need to implement a few traits and defer the comparision to the elements of the array using a helper method <code class=\"language-text\">get_item</code> (we define). On the <code class=\"language-text\">Item</code> struct we'll implement the required traits (<code class=\"language-text\">PartialEq</code>, <code class=\"language-text\">PartialOrd</code>, <code class=\"language-text\">Ord</code>) so that it can be inserted into min-heap:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">impl</span><span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span> PartialEq <span class=\"token keyword\">for</span> Item<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fn</span> <span class=\"token function\">eq</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> other<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">Self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> bool <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">get_item</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> other<span class=\"token punctuation\">.</span><span class=\"token function\">get_item</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">impl</span><span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span> PartialOrd <span class=\"token keyword\">for</span> Item<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fn</span> <span class=\"token function\">partial_cmp</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> other<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">Self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> Option<span class=\"token operator\">&lt;</span>Ordering<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">get_item</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">partial_cmp</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>other<span class=\"token punctuation\">.</span><span class=\"token function\">get_item</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">impl</span><span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span> Ord <span class=\"token keyword\">for</span> Item<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fn</span> <span class=\"token function\">cmp</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> other<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">Self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> Ordering <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">get_item</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">cmp</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>other<span class=\"token punctuation\">.</span><span class=\"token function\">get_item</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>    \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We also have a few helper methods <code class=\"language-text\">new</code> and <code class=\"language-text\">get_item</code> purely for convenience.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">impl</span><span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span> Item<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fn</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'a</span> Vec<span class=\"token operator\">&lt;</span>i32<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> idx<span class=\"token punctuation\">:</span> usize<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token keyword\">Self</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">Self</span> <span class=\"token punctuation\">{</span>\n            arr<span class=\"token punctuation\">,</span>\n            idx\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">fn</span> <span class=\"token function\">get_item</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> i32 <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>arr<span class=\"token punctuation\">[</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>idx<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Once we have the required traits implemented for <code class=\"language-text\">Item</code>, we'll then implement the new <code class=\"language-text\">merge</code> algorithm:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">use</span> std<span class=\"token punctuation\">::</span>collections<span class=\"token punctuation\">::</span>BinaryHeap<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">use</span> std<span class=\"token punctuation\">::</span>cmp<span class=\"token punctuation\">::</span>Reverse<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">use</span> std<span class=\"token punctuation\">::</span>cmp<span class=\"token punctuation\">::</span>Ordering<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>arrays<span class=\"token punctuation\">:</span> Vec<span class=\"token operator\">&lt;</span>Vec<span class=\"token operator\">&lt;</span>i32<span class=\"token operator\">>></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> Vec<span class=\"token operator\">&lt;</span>i32<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> sorted <span class=\"token operator\">=</span> <span class=\"token function\">vec!</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> heap <span class=\"token operator\">=</span> BinaryHeap<span class=\"token punctuation\">::</span><span class=\"token function\">with_capacity</span><span class=\"token punctuation\">(</span>arrays<span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> arr <span class=\"token keyword\">in</span> <span class=\"token operator\">&amp;</span>arrays <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> item <span class=\"token operator\">=</span> Item<span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        heap<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token function\">Reverse</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">while</span> <span class=\"token operator\">!</span>heap<span class=\"token punctuation\">.</span><span class=\"token function\">is_empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> it <span class=\"token operator\">=</span> heap<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unwrap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        sorted<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>it<span class=\"token number\">.0</span><span class=\"token punctuation\">.</span><span class=\"token function\">get_item</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        it<span class=\"token number\">.0</span><span class=\"token punctuation\">.</span>idx <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> it<span class=\"token number\">.0</span><span class=\"token punctuation\">.</span>idx <span class=\"token operator\">&lt;</span> it<span class=\"token number\">.0</span><span class=\"token punctuation\">.</span>arr<span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            heap<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    sorted\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We create a <code class=\"language-text\">Vec</code> that will hold our merged items. We then create a <code class=\"language-text\">BinaryHeap</code> instance and push all items in <code class=\"language-text\">arrays</code> as an <code class=\"language-text\">Item</code> with the start index <code class=\"language-text\">0</code>. We then wrap <code class=\"language-text\">item</code> with <code class=\"language-text\">Reverse</code> (as it's a max heap by default) and push it to heap.</p>\n<p>Next, we run a loop while we still have elements in heap. Within the loop, we get the smallest item by <code class=\"language-text\">heap.pop()</code> and push it to <code class=\"language-text\">sorted</code> and increment the item's index by 1. Because we might still have items in the heap, we check for that and push it back in the last line.</p>\n<p>Finally once we are done, we return the <code class=\"language-text\">sorted</code> array.</p>\n<p>For this solution our complexity now reduces to `O(n*k * Log(k))</p>\n<p>Finally let's test this out on a sample dataset:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token function\">vec!</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> <span class=\"token function\">vec!</span><span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> v <span class=\"token operator\">=</span> <span class=\"token function\">vec!</span><span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dbg!</span><span class=\"token punctuation\">(</span><span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Final code: <a href=\"https://gist.github.com/creativcoder/20fda0f1a947bf2af3b93ab394d6bacb\">https://gist.github.com/creativcoder/20fda0f1a947bf2af3b93ab394d6bacb</a></p>\n<h2>Taking it a step further</h2>\n<p>An optimization on top of this would be to stream sorted values as they are processed by exposing an iterator over the <code class=\"language-text\">k</code> items in heap.</p>\n<p>With that said, I am open to suggestions, improvements to the solution and you can do so with comments below. Until next time!</p>","excerpt":"The other day, I was reading about LSM Tree based database storage engines (specifically, the LevelDB docs) where I came to know about aâ€¦"}},"pageContext":{"type":"posts","next":{"frontmatter":{"path":"/setup-nextjs-tailwind","title":"How to setup NextJS with TailwindCSS ðŸŒŠ","tags":["tailwindcss","react","nextjs","stylesheets","frontend"]},"fileAbsolutePath":"/home/creativcoder/opensource/creativcoder.dev/src/posts/setup-nextjs-tailwind.md"},"previous":null}}}